<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>mx's Blog</title><link href="http://x-wei.github.io" rel="alternate"></link><link href="http://x-wei.github.io/feeds/notes.atom.xml" rel="self"></link><id>http://x-wei.github.io</id><updated>2015-09-26T00:00:00+02:00</updated><entry><title>lin-reg = max-likelihood: 贝叶斯视角看线性回归</title><link href="http://x-wei.github.io/linreg-bayes.html" rel="alternate"></link><updated>2015-09-26T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/linreg-bayes.html</id><summary type="html">&lt;p&gt;几乎所有的ml课都是从线性回归讲起, ETH的课也不例外. 不过这次老师用了贝叶斯的视角讲这个问题, 自从高中接触丁老师讲的线性回归以来 第一次听到一个不同于最小二乘的解读, 感觉很有意思. 又想起来刘未鹏那篇非常棒的&lt;a href="http://mindhacks.cn/2008/09/21/the-magical-bayesian-method/"&gt;博客&lt;/a&gt;, 于是想记录一下.    &lt;/p&gt;
&lt;h2&gt;notation&lt;/h2&gt;
&lt;p&gt;首先有n个数据点:  &lt;br /&gt;
&lt;img alt="" src="linreg-bayes/pasted_image001.png" /&gt; &lt;br /&gt;
其中y是实数, 每个x有d个维度, 为了方便表示截距, 再给x加入一个始终等于1的维度:  &lt;br /&gt;
&lt;img alt="" src="linreg-bayes/pasted_image002.png" /&gt; &lt;br /&gt;
例子: y代表房价, x代表了房子的面积, 使用时间, 距离市中心的距离等因素.   &lt;/p&gt;
&lt;h2&gt;least square viewpoint&lt;/h2&gt;
&lt;p&gt;在最小二乘的视角里, 线性回归是用一个x的线性函数拟合y:  &lt;br /&gt;
&lt;img alt="" src="linreg-bayes/pasted_image003.png" /&gt; &lt;br /&gt;
使得拟合结果和观测结果的误差尽量小.  &lt;br /&gt;
不过这次不说最小二乘, 所以接下来不讨论这个思路...   &lt;/p&gt;
&lt;h2&gt;assumptions in Bayes viewpoint&lt;/h2&gt;
&lt;p&gt;在贝叶斯视角里, 我们假设: &lt;br /&gt;
&lt;strong&gt;假设1. y = 某个x的线性函数 + 观测噪音&lt;/strong&gt; &lt;br /&gt;
即:  &lt;br /&gt;
&lt;img alt="" src="linreg-bayes/pasted_image006.png" /&gt; &lt;br /&gt;
其中εi是一个&lt;em&gt;随机变量&lt;/em&gt;, 所以y也是一个随机变量.  &lt;br /&gt;
另外再有一个比较强的假设: &lt;br /&gt;
&lt;strong&gt;假设2.  ε服从centered高斯分布, iid.&lt;/strong&gt; &lt;br /&gt;
&lt;img alt="" src="linreg-bayes/pasted_image007.png" /&gt; &lt;br /&gt;
(btw, 对一个随机变量建模, 一般来说, 连续随机变量就用高斯, 离散随机变量用泊松)   &lt;/p&gt;
&lt;h2&gt;Bayes formula&lt;/h2&gt;
&lt;p&gt;贝叶斯公式长这个样子:  &lt;br /&gt;
&lt;img alt="" src="linreg-bayes/pasted_image004.png" /&gt; &lt;br /&gt;
只看最左边和最右边的内容, 表达为:    &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;posterior = likelihood * prior &lt;br /&gt;
后验概率 = 可能性 * 先验概率   &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(上面其实应该是"正比于"而不是等号, 由于P(Y)我们并不关心, 所以可以直接忽略之)   &lt;/p&gt;
&lt;p&gt;公式里Y代表可以观察到结果, X代表结果背后不能直接观察的量(&lt;em&gt;不要和数据里的XY混淆...&lt;/em&gt;).  &lt;br /&gt;
贝叶斯公式的意义在于, 让我们从可观测的Y反推不可观测的X的概率. 既然我们已经得到了观测结果Y, 那么找到使得后验概率最大的X就说明我们在观测基础上得到了最可信的X的估计.    &lt;/p&gt;
&lt;p&gt;那么在我们这个问题里, X代表模型, 即某一个β的取值; Y代表观测结果, 即我们看到的n个数据点.  &lt;br /&gt;
&lt;img alt="" src="linreg-bayes/pasted_image005.png" /&gt; &lt;br /&gt;
所以我们的问题就是: 在已经有了这些观测点的基础之上, 应该选那个β的取值, 使得后验概率最大?   &lt;/p&gt;
&lt;h2&gt;lin-reg = max-likelihood&lt;/h2&gt;
&lt;p&gt;线性回归认为, 对于任意的β的取值, 其先验概率都是一样的, 所以在贝叶斯公式里可以忽略ℙ(X), 只需要考虑最大化likelihood ℙ(Y|​X)即可 — 再一次, 不要把贝叶斯的XY和数据的X和Y混淆...  &lt;br /&gt;
即选择β: &lt;br /&gt;
&lt;img alt="" src="linreg-bayes/pasted_image015.png" /&gt;  &lt;br /&gt;
由于随机变量y只是随机变量ε的一个函数(且给定β, ε和y一一对应):  &lt;br /&gt;
&lt;img alt="" src="linreg-bayes/pasted_image008.png" /&gt; &lt;br /&gt;
所以可以最大化ε的likelihood:  &lt;br /&gt;
&lt;img alt="" src="linreg-bayes/pasted_image009.png" /&gt; &lt;br /&gt;
由于之前对ε有假设:  &lt;br /&gt;
&lt;img alt="" src="linreg-bayes/pasted_image010.png" /&gt; &lt;br /&gt;
那么:  &lt;br /&gt;
&lt;img alt="" src="linreg-bayes/pasted_image011.png" /&gt; &lt;br /&gt;
(不要以为ε独立于β: ε=y - βt x, 所以上面表达式里其实还是有β的. ) &lt;br /&gt;
⇒ 两边取log并加上负号:  &lt;br /&gt;
&lt;img alt="" src="linreg-bayes/pasted_image014.png" /&gt; &lt;br /&gt;
Voila, 所以极大似然=最小二乘!  &lt;br /&gt;
对, 饶了一圈还是最小二乘, 但是这样的意义变了, 明白了为什么要最小化平方误差这个值.   &lt;/p&gt;
&lt;h2&gt;precise solution to linreg&lt;/h2&gt;
&lt;p&gt;(notation有点混乱了, 之前贝叶斯里面应该用AB而不是用XY的orz...) &lt;br /&gt;
每个x是一个列向量, 这里, 把所有数据用矩阵形式表示:  &lt;br /&gt;
&lt;img alt="" src="linreg-bayes/pasted_image016.png" /&gt; &lt;br /&gt;
矩阵表示的好处是平方误差可以用矩阵表示:  &lt;br /&gt;
&lt;img alt="" src="linreg-bayes/pasted_image017.png" /&gt; &lt;br /&gt;
&lt;img alt="" src="linreg-bayes/pasted_image018.png" /&gt; &lt;br /&gt;
对矩阵运算求偏导, 偏导为0的时候即可得到最优的β: &lt;br /&gt;
&lt;img alt="" src="linreg-bayes/pasted_image019.png" /&gt;   &lt;/p&gt;</summary><category term="ml"></category></entry><entry><title>[Algorithms I] Week 6 Hash Tables</title><link href="http://x-wei.github.io/algoI_week6.html" rel="alternate"></link><updated>2015-09-01T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/algoI_week6.html</id><summary type="html">&lt;p&gt;&lt;em&gt;Can we do better than BST if we do not need ordered operations ?&lt;/em&gt;   &lt;/p&gt;
&lt;p&gt;(No compare methods, use equals method)   &lt;/p&gt;
&lt;p&gt;Idea: save items in an array.  &lt;br /&gt;
&lt;strong&gt;Hash function&lt;/strong&gt;: method for calclulating the array index of  a key.    &lt;/p&gt;
&lt;p&gt;Issues:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;computing hash function   &lt;/li&gt;
&lt;li&gt;equality tests   &lt;/li&gt;
&lt;li&gt;collision resolution   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;Classic space-time tradeoff.&lt;/em&gt;   &lt;/p&gt;
&lt;h1&gt;1. Hash Functions&lt;/h1&gt;
&lt;p&gt;Goal: scramble the keys uniformly to produce a table index.    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;effcient to compute   &lt;/li&gt;
&lt;li&gt;all indices are equally likely for any key   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;challenge: need different approach for different key types.    &lt;/p&gt;
&lt;h2&gt;Java's hashing&lt;/h2&gt;
&lt;p&gt;All java object has a methode &lt;code&gt;int hashCode()&lt;/code&gt; &lt;br /&gt;
requirement:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if x.equals(y) ⇒ x.hashCode()==y.hashCode()   &lt;/li&gt;
&lt;li&gt;
&lt;p&gt;(hopefully) if x.equals(y)==false ⇒ x.hashCode!=y.hashCode()   &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Default implementation: &lt;em&gt;memory address&lt;/em&gt; for x.    &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Custom implementations for standard types: Integer, Double, String, File, URL, Date...   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week6/pasted_image.png" /&gt; &lt;br /&gt;
Strings: Horner's method — compute a polynome.  &lt;br /&gt;
&lt;img alt="" src="algoI_week6/pasted_image001.png" /&gt; &lt;br /&gt;
recipe for user-defined types:  &lt;br /&gt;
&lt;img alt="" src="algoI_week6/pasted_image002.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;Modeular hasing&lt;/h2&gt;
&lt;p&gt;(hash code VS hash function)   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Hash code&lt;/em&gt;: 32-bit integer between -2^31 and 2^31-1 &lt;em&gt;(can be negative!!)&lt;/em&gt;   &lt;/li&gt;
&lt;li&gt;&lt;em&gt;Hash function&lt;/em&gt;: integer between 0 and M-1 (used directly as array index, should &amp;gt;=0)   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;BUG code:&lt;/strong&gt;    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Key&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hashCode&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;M&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;→ bug: &lt;em&gt;number returned can be negative !&lt;/em&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1-in-billion bug code:&lt;/strong&gt;  &lt;br /&gt;
&lt;code&gt;return Math.abs(k.hashCode()) % M;&lt;/code&gt;   &lt;/p&gt;
&lt;p&gt;→ bug: Math.abs() returns negative numbers for -2^31 &lt;br /&gt;
&lt;img alt="" src="algoI_week6/pasted_image003.png" /&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;correct code:&lt;/strong&gt; &lt;br /&gt;
just take the first 31 bits: x&amp;amp;0x7fffffff &lt;br /&gt;
&lt;code&gt;return k.hashCode()&amp;amp;0x7fffffff % M;&lt;/code&gt;   &lt;/p&gt;
&lt;p&gt;另一个hash的思路是用random(用hashcode作为随机种子)   &lt;/p&gt;
&lt;h2&gt;uniform hasing assumption&lt;/h2&gt;
&lt;p&gt;each key is equally likely to hash to an integer between 0 and M-1   &lt;/p&gt;
&lt;p&gt;一些数学结论:  &lt;br /&gt;
&lt;img alt="" src="algoI_week6/pasted_image004.png" /&gt;   &lt;/p&gt;
&lt;h1&gt;2. Separate Chaining&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;one strategy for collision resolution.&lt;/em&gt;  &lt;br /&gt;
&lt;img alt="" src="algoI_week6/pasted_image005.png" /&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;idea&lt;/strong&gt;: Using a table of size M &amp;lt; N,  build a list for each of the table positions.    &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week6/pasted_image006.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;implementation&lt;/h2&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;SeparateChainingHashST&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Value&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;   
    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;M&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;97&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;st&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;97&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;   
    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;   
        &lt;span class="n"&gt;Object&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// no generic array creation!    &lt;/span&gt;
        &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
        &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Key&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Value&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="n"&gt;nxt&lt;/span&gt;&lt;span class="p"&gt;){...}&lt;/span&gt;   
    &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Key&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hashCode&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="mh"&gt;0x7fffffff&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;M&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Value&lt;/span&gt; &lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Key&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;st&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;equals&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//cast   &lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;put&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Key&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Value&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;st&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;equals&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;    
                &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;   
        &lt;span class="n"&gt;st&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;st&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;   
    &lt;span class="p"&gt;}&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意内部类Node里用的是Object — 因为不能声明generic array.    &lt;/p&gt;
&lt;h2&gt;analysis&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;proposition&lt;/strong&gt; &lt;br /&gt;
Under the assumption of uniform hashing, the number of keys in a list is within a constant factor to N/M.  &lt;br /&gt;
&lt;em&gt;proof.&lt;/em&gt; &lt;br /&gt;
binominal distribution.   &lt;/p&gt;
&lt;p&gt;M times faster than sequential search &lt;br /&gt;
→ typical choice: M ~ N/5   &lt;/p&gt;
&lt;h1&gt;3. Linear Probing&lt;/h1&gt;
&lt;p&gt;Another approch for collision resolution.    &lt;/p&gt;
&lt;p&gt;idea: &lt;strong&gt;open addressing&lt;/strong&gt; &lt;br /&gt;
Use an array of size &lt;strong&gt;M&amp;gt;N&lt;/strong&gt;, when a key collides, &lt;em&gt;find next open slot&lt;/em&gt;.  &lt;br /&gt;
&lt;img alt="" src="algoI_week6/pasted_image007.png" /&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;insert: when occupied, move pointer until got open slot   &lt;/li&gt;
&lt;li&gt;search: when not found, move pointer until find or reach open slot   &lt;/li&gt;
&lt;li&gt;&lt;em&gt;delete&lt;/em&gt;: set key to null, then for all items behind this key: set to null, then insert this key......   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;array M &lt;em&gt;must&lt;/em&gt; be larger than N ⇒ array resizing is necessary.    &lt;/p&gt;
&lt;h2&gt;implementation&lt;/h2&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;LinearProbingHashST&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Value&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;   
    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;M&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;keys&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//cannot use generic array   &lt;/span&gt;
    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;vals&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;put&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Key&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Value&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(;&lt;/span&gt;&lt;span class="n"&gt;keys&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;M&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;keys&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;equals&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;    
                &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;vals&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;   
        &lt;span class="n"&gt;keys&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
        &lt;span class="n"&gt;vals&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Value&lt;/span&gt; &lt;span class="nf"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Key&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(;&lt;/span&gt;&lt;span class="n"&gt;keys&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;M&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;equals&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;keys&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;vals&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="c1"&gt;//ugly cast   &lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="p"&gt;}&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;cluster&lt;/h2&gt;
&lt;p&gt;def. &lt;strong&gt;cluster&lt;/strong&gt; &lt;br /&gt;
A contiguous block of items.    &lt;/p&gt;
&lt;p&gt;New keys are more likely to hash into a cluster.    &lt;/p&gt;
&lt;p&gt;Knuth parking pb:  &lt;br /&gt;
&lt;img alt="" src="algoI_week6/pasted_image008.png" /&gt; &lt;br /&gt;
&lt;img alt="" src="algoI_week6/pasted_image010.png" /&gt; &lt;br /&gt;
&lt;img alt="" src="algoI_week6/pasted_image009.png" /&gt; &lt;br /&gt;
(当年Knuth就是在证明了这个以后决定写那套书)   &lt;/p&gt;
&lt;p&gt;Typical choice: &lt;strong&gt;N/M ~ 1/2&lt;/strong&gt; (3/2 for search hit and 5/2 for search miss)   &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week6/pasted_image011.png" /&gt;   &lt;/p&gt;
&lt;h1&gt;4. Hash Table Context&lt;/h1&gt;
&lt;p&gt;widely used in applicataions.    &lt;/p&gt;
&lt;p&gt;cost for computing hash VS cost for searching:  &lt;br /&gt;
hashCode() for strings in java 1.1: exemain only 8-9 evenly spaced characters to save time. &lt;br /&gt;
&lt;img alt="" src="algoI_week6/pasted_image012.png" /&gt;   &lt;/p&gt;
&lt;p&gt;uniform hashing assumption: performance not guaranteed... &lt;br /&gt;
&lt;img alt="" src="algoI_week6/pasted_image013.png" /&gt;   &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week6/pasted_image014.png" /&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;one-way hash functions&lt;/strong&gt; &lt;br /&gt;
Hard to find a key that hash to a desired value, or 2 keys having the same hash value.  &lt;br /&gt;
&lt;img alt="" src="algoI_week6/pasted_image015.png" /&gt; &lt;br /&gt;
used for fingurprints or store passwords, but too expensive for ST implementations.    &lt;/p&gt;
&lt;h2&gt;Seperate chaining VS linear probing&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week6/pasted_image016.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;variations&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week6/pasted_image017.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;ST choice: hash tables VS balanced search trees&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week6/pasted_image018.png" /&gt;   &lt;/p&gt;</summary><category term="algorithm"></category></entry><entry><title>[Algorithms I] Week 5-2 Geometric Applications of BSTs</title><link href="http://x-wei.github.io/algoI_week5_2.html" rel="alternate"></link><updated>2015-08-29T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/algoI_week5_2.html</id><summary type="html">&lt;h1&gt;1. 1d Range Search&lt;/h1&gt;
&lt;p&gt;Goal: &lt;em&gt;intersections&lt;/em&gt; of geometric objects.  &lt;br /&gt;
&lt;img alt="" src="algoI_week5_2/pasted_image.png" /&gt; &lt;br /&gt;
Solution: &lt;strong&gt;BST&lt;/strong&gt;   &lt;/p&gt;
&lt;h2&gt;1d range search&lt;/h2&gt;
&lt;p&gt;operations required:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;insert   &lt;/li&gt;
&lt;li&gt;search   &lt;/li&gt;
&lt;li&gt;delete   &lt;/li&gt;
&lt;li&gt;&lt;em&gt;range search&lt;/em&gt;: all keys between k1 and k2   &lt;/li&gt;
&lt;li&gt;&lt;em&gt;range count&lt;/em&gt;: how many keys are between k1 and k2   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;→ find points on an interval  &lt;br /&gt;
&lt;img alt="" src="algoI_week5_2/pasted_image001.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;implementation by BST&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;range count&lt;/strong&gt; &lt;br /&gt;
using the &lt;code&gt;rank()&lt;/code&gt; function for the BST (or use the size of a tree) &lt;br /&gt;
&lt;img alt="" src="algoI_week5_2/pasted_image002.png" /&gt; &lt;br /&gt;
注意什么时候要加1...   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;size&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Key&lt;/span&gt; &lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt; &lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;contains&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;rank&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;rank&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;rank&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;rank&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;range search&lt;/strong&gt; &lt;br /&gt;
类似inorder traversal的方式:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;find in left subtree (if could fall into range)   &lt;/li&gt;
&lt;li&gt;check current node   &lt;/li&gt;
&lt;li&gt;find in right subtree   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week5_2/pasted_image003.png" /&gt; &lt;br /&gt;
running time: R+lgN (R=nb of nodes in range)   &lt;/p&gt;
&lt;h1&gt;2. Line Segment Intersection&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Orthognal line segment intersection search&lt;/em&gt;:  &lt;br /&gt;
find all intersections given N horizontal/vertical lines &lt;br /&gt;
&lt;img alt="" src="algoI_week5_2/pasted_image005.png" /&gt;   &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Non-degeneracy assumption: all x-coord and y-coord are distinct.    &lt;/p&gt;
&lt;p&gt;naive algo: check all pairs...   &lt;/p&gt;
&lt;h2&gt;Sweep-line algorithm&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week5_2/pasted_image006.png" /&gt; &lt;br /&gt;
&lt;img alt="" src="algoI_week5_2/pasted_image007.png" /&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sweep a vertical line from left to right.    &lt;ul&gt;
&lt;li&gt;when hit the left end of horizontal-segment (h-seg) → insert into a BST   &lt;/li&gt;
&lt;li&gt;when hit the right end of a h-seg → delete from BST   &lt;/li&gt;
&lt;li&gt;when hit a vertical-seg: ⇒ 1d range search !    &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;关于怎么sweep的:&lt;/strong&gt; &lt;br /&gt;
没有仔细讲, 不过我觉得就是把所有的x坐标排好序, 有个&lt;a href="https://leetcode.com/problems/the-skyline-problem/"&gt;skyline问题&lt;/a&gt;也是涉及如何sweep的.   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;proposition&lt;/strong&gt; &lt;br /&gt;
running time is NlgN+R (R=nb of intersections).  &lt;br /&gt;
&lt;em&gt;proof.&lt;/em&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sort by x-coord (or use PQ) → NlgN   &lt;/li&gt;
&lt;li&gt;insert/delete y-coord to BST → NlgN   &lt;/li&gt;
&lt;li&gt;range search → NlgN + R   &lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;3. Kd-trees&lt;/h1&gt;
&lt;p&gt;An extension of BST: &lt;em&gt;2d-keys&lt;/em&gt;.    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;insert: insert 2d points   &lt;/li&gt;
&lt;li&gt;search   &lt;/li&gt;
&lt;li&gt;range search: &lt;em&gt;find all keys lying in a 2d rectangle (h-v rectangle)&lt;/em&gt;   &lt;/li&gt;
&lt;li&gt;range count   &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;gird implementation&lt;/h2&gt;
&lt;p&gt;divide space into a M-by-M grid (uniform squares). &lt;br /&gt;
space: N + M^2 &lt;br /&gt;
time: 1 + N/M^2  &lt;br /&gt;
→ choose square to balance space and time.  &lt;br /&gt;
problem: points are not uniformly distributed.  &lt;br /&gt;
&lt;img alt="" src="algoI_week5_2/pasted_image008.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;2d tree&lt;/h2&gt;
&lt;p&gt;Use a tree to represent the subdivision of the space.    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2d tree&lt;/strong&gt;: recursively divide the space into 2 halfplanes &lt;br /&gt;
&lt;img alt="" src="algoI_week5_2/pasted_image009.png" /&gt;   &lt;/p&gt;
&lt;p&gt;construct the 2d tree by adding points: &lt;em&gt;alternating between horizontal and vertical partitioning for each level of tree&lt;/em&gt;.  &lt;br /&gt;
&lt;img alt="" src="algoI_week5_2/pasted_image010.png" /&gt;   &lt;/p&gt;
&lt;p&gt;Data structure: BST alternating x and y-coords as key.  &lt;br /&gt;
&lt;img alt="" src="algoI_week5_2/pasted_image011.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;Range search for 2d tree&lt;/h2&gt;
&lt;p&gt;find all points lying in a rectangle.  &lt;br /&gt;
依然类似tree traversal算法:   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;check point in node   &lt;/li&gt;
&lt;li&gt;find in left subtree (if could be in range — the rectangle &lt;em&gt;intersects&lt;/em&gt; the splitting line)   &lt;/li&gt;
&lt;li&gt;find in right subtree   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week5_2/pasted_image012.png" /&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;analysis&lt;/strong&gt; &lt;br /&gt;
Typical case: R + lgN &lt;br /&gt;
worst case: R+ sqrt(N) (even if tree is balanced) &lt;br /&gt;
(proof is hard)   &lt;/p&gt;
&lt;h2&gt;Nearest Neighbour seach&lt;/h2&gt;
&lt;p&gt;find closest point to a query point.    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;check dist from query point to node   &lt;/li&gt;
&lt;li&gt;check in left tree (&lt;em&gt;if could contain a closer point — 和两点连线与splitting line的角度有关系&lt;/em&gt;)   &lt;/li&gt;
&lt;li&gt;check in right tree   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;analysis&lt;/strong&gt; &lt;br /&gt;
typical case: lgN &lt;br /&gt;
worst case: N   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Flocking boids&lt;/strong&gt; &lt;br /&gt;
3 simple rules to get a simulation of flocking.  &lt;br /&gt;
&lt;img alt="" src="algoI_week5_2/pasted_image013.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;Kd tree&lt;/h2&gt;
&lt;p&gt;partition the k-dim space into 2 halfspaces.  &lt;br /&gt;
cycle through k dimensions. &lt;br /&gt;
&lt;img alt="" src="algoI_week5_2/pasted_image014.png" /&gt; &lt;br /&gt;
(居然时一个本科生发现的!)   &lt;/p&gt;
&lt;p&gt;Nbody simulation: &lt;br /&gt;
treat clusters as an aggregated node   &lt;/p&gt;
&lt;h1&gt;4. Interval search tree&lt;/h1&gt;
&lt;p&gt;1d interval search:　data are intervals   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;insert interval    &lt;/li&gt;
&lt;li&gt;search interval   &lt;/li&gt;
&lt;li&gt;delete interval   &lt;/li&gt;
&lt;li&gt;intersection query: find all intervals that intersects (lo,hi)   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week5_2/pasted_image015.png" /&gt; &lt;br /&gt;
Nondegeneracy assumption: all left endpoint of intervals are distinct.    &lt;/p&gt;
&lt;p&gt;API:   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nx"&gt;put&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;Key&lt;/span&gt; &lt;span class="nx"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;Key&lt;/span&gt; &lt;span class="nx"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;Value&lt;/span&gt; &lt;span class="nx"&gt;val&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   
&lt;span class="nb"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;Key&lt;/span&gt; &lt;span class="nx"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;Key&lt;/span&gt; &lt;span class="nx"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   
&lt;span class="nb"&gt;delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;Key&lt;/span&gt; &lt;span class="nx"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;Key&lt;/span&gt; &lt;span class="nx"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   
&lt;span class="nx"&gt;Iterable&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;Key&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;intersects&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;Key&lt;/span&gt; &lt;span class="nx"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;Key&lt;/span&gt; &lt;span class="nx"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Interval search tree:&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;BST using left endpoint as key   &lt;/li&gt;
&lt;li&gt;in each node: store the &lt;em&gt;max right endpoint of the subtree&lt;/em&gt;   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week5_2/pasted_image016.png" /&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;insert&lt;/strong&gt; &lt;br /&gt;
类似BST, 加上维护一下maxendpoint即可.   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;search&lt;/strong&gt; &lt;br /&gt;
search &lt;em&gt;any one&lt;/em&gt; interval that intersects (lo,hi)   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if node intersects, return   &lt;/li&gt;
&lt;li&gt;if left.maxendpoint &amp;lt; lo: go right   &lt;/li&gt;
&lt;li&gt;else: go left   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;*proof. * &lt;br /&gt;
主要证明一点: if no intersection to left ⇒ then no intersection to the right &lt;br /&gt;
&lt;img alt="" src="algoI_week5_2/pasted_image018.png" /&gt;   &lt;/p&gt;
&lt;h1&gt;5. Rectangle intersection&lt;/h1&gt;
&lt;p&gt;Goal:  find all intersection among N rectangles.  &lt;br /&gt;
(non degeneracy assumption: all x and y are distinct)    &lt;/p&gt;
&lt;p&gt;bottom line: linearithmic algo.    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;sweep-line algorithm:&lt;/strong&gt; &lt;br /&gt;
sweep vertical line from left to right.    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;when hit left part of a rect ⇒ put into an interval search tree   &lt;/li&gt;
&lt;li&gt;when hit right part of a rect ⇒ remove interval   &lt;/li&gt;
&lt;li&gt;every time befor adding ⇒ check intersection   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;reduces the 2d rect intersection pb to 1d interval search pb.&lt;/em&gt;    &lt;/p&gt;
&lt;p&gt;complexity:  &lt;br /&gt;
NlgN+RlgN   &lt;/p&gt;
&lt;p&gt;summery:  &lt;br /&gt;
&lt;img alt="" src="algoI_week5_2/pasted_image019.png" /&gt;   &lt;/p&gt;</summary><category term="algorithm"></category></entry><entry><title>[Algorithms I] Week 5-1 Balanced Search Trees</title><link href="http://x-wei.github.io/algoI_week5_1.html" rel="alternate"></link><updated>2015-08-26T16:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/algoI_week5_1.html</id><summary type="html">&lt;p&gt;goal: lgN for insert/search/delete operations (not necessarily &lt;em&gt;binary&lt;/em&gt; trees..) &lt;br /&gt;
3 algo: 2-3 tree, (left leaning) red-black tree, B-tree   &lt;/p&gt;
&lt;h1&gt;1. 2-3 Search Trees&lt;/h1&gt;
&lt;p&gt;def. &lt;strong&gt;2-3 tree&lt;/strong&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;allow 1 or 2 keys per node, &amp;amp; 2 or 3 children per node:    &lt;ul&gt;
&lt;li&gt;2-node: one key, 2 children (ordinary BST node)   &lt;/li&gt;
&lt;li&gt;3-node: 2 keys, 3 children (3 children: &lt;em&gt;less, between, more&lt;/em&gt;)   &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;perfect balance&lt;/strong&gt;: every path from root to null link has the same length (2-3 tree的一个超好的性质, &lt;em&gt;类似于一个满二叉树&lt;/em&gt;!)   &lt;/li&gt;
&lt;li&gt;symmetric order: inorder traversal gives ascending order (和BST类似)   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week5_1/pasted_image.png" /&gt; &lt;br /&gt;
&lt;strong&gt;search&lt;/strong&gt; &lt;br /&gt;
Just follow the correct link... Natural generalization of search in BST...    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;insert&lt;/strong&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;case 1: insert into a 2-node at bottom   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;just convert a 2-node into a 3-node   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;case 2: insert into a 3-node at bottom   &lt;ul&gt;
&lt;li&gt;create a temporary 4-node (three keys)   &lt;/li&gt;
&lt;li&gt;move middle key in 4-node into parent, split the rest two keys into two 2-nodes   &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week5_1/pasted_image001.png" /&gt;   &lt;img alt="" src="algoI_week5_1/pasted_image002.png" /&gt;    &lt;img alt="" src="algoI_week5_1/pasted_image003.png" /&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if parent becom a 3-node → continue the process   &lt;/li&gt;
&lt;li&gt;if arrived at the root (root is a 4-node with three keys): split it into three 2-nodes   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week5_1/pasted_image004.png" /&gt; &lt;img alt="" src="algoI_week5_1/pasted_image005.png" /&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;splitting a 4-node&lt;/strong&gt;: can be done in constant time (&lt;em&gt;local transformation&lt;/em&gt;).  &lt;br /&gt;
&lt;img alt="" src="algoI_week5_1/pasted_image006.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;Analysis&lt;/h2&gt;
&lt;p&gt;Invariant: maintains symmetric order and perfect balance.  &lt;br /&gt;
&lt;em&gt;proof.&lt;/em&gt;  &lt;br /&gt;
each transformation maintains the order and the balance, all possible transformations:  &lt;br /&gt;
这个图很好, 3-node的插入一共有三种情况: 自身是root/父亲是2-node/父亲是3-node &lt;br /&gt;
&lt;img alt="" src="algoI_week5_1/pasted_image007.png" /&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;performance&lt;/strong&gt; &lt;br /&gt;
every path from root to null link has the same length.  &lt;br /&gt;
&lt;img alt="" src="algoI_week5_1/pasted_image008.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;Implementation&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;direct implementation is complicated:    &lt;/li&gt;
&lt;li&gt;bottom line: &lt;em&gt;Could do it, but there's a better way.&lt;/em&gt;   &lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;2. Red-Black BST&lt;/h1&gt;
&lt;p&gt;LLRB tree: left-leaning red-black tree.    &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;BST representation of the 2-3 trees&lt;/em&gt; &lt;br /&gt;
&lt;strong&gt;use internal left-leaning links for 3 nodes&lt;/strong&gt;   &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;红色link即为internal left leaning link (红黑树就是这么来的), 用红色link连接起来的组成一个(虚拟的)3-node 或4-node.    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;3-node用一个red link表示:    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week5_1/pasted_image009.png" /&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;4-node用两个red link表示:    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week5_1/pasted_image030.png" /&gt; ⇒ &lt;img alt="" src="algoI_week5_1/pasted_image029.png" /&gt; or &lt;img alt="" src="algoI_week5_1/pasted_image027.png" /&gt; or &lt;img alt="" src="algoI_week5_1/pasted_image028.png" /&gt;   &lt;/p&gt;
&lt;p&gt;example:  &lt;br /&gt;
&lt;img alt="" src="algoI_week5_1/pasted_image010.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;properties&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;no node has two red links (不可以一个节点连两个red link)   &lt;/li&gt;
&lt;li&gt;every path from path to null link has the same number of &lt;em&gt;black&lt;/em&gt; links (想象所有red link都变为horizontal)   &lt;/li&gt;
&lt;li&gt;all red links lean left   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week5_1/pasted_image011.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;representation&lt;/h2&gt;
&lt;p&gt;Each node has only one link from parent  &lt;br /&gt;
⇒ add a boolean to encode color of links (the color of the link &lt;em&gt;from parent&lt;/em&gt;).  &lt;br /&gt;
&lt;img alt="" src="algoI_week5_1/pasted_image012.png" /&gt;   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;   
    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;Value&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="n"&gt;boolean&lt;/span&gt; &lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//true means red     &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;    
&lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;boolean&lt;/span&gt; &lt;span class="n"&gt;isRed&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;insert to parent 操作: 只需把color变为RED即表示该节点 被变成了和父节点一起的一个(虚拟)节点.    &lt;/p&gt;
&lt;h2&gt;elementary operations&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;left-rotation&lt;/strong&gt; &lt;br /&gt;
(def: &lt;em&gt;convert a right-learning red link to left.&lt;/em&gt; ) &lt;br /&gt;
&lt;img alt="" src="algoI_week5_1/pasted_image013.png" /&gt;   &lt;img alt="" src="algoI_week5_1/pasted_image014.png" /&gt; &lt;br /&gt;
(symmetric ordering and perfect black balance are maintained)    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="nf"&gt;rotateLeft&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;    
    &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// not = BLACK   &lt;/span&gt;
    &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;RED&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;right-rotation&lt;/strong&gt; &lt;br /&gt;
(temporarily turn a left-leaning red link to right) &lt;br /&gt;
&lt;img alt="" src="algoI_week5_1/pasted_image015.png" /&gt; &lt;img alt="" src="algoI_week5_1/pasted_image016.png" /&gt;   &lt;/p&gt;
&lt;p&gt;&lt;code&gt;private Node rotateRight(Node h){...}&lt;/code&gt;   &lt;/p&gt;
&lt;p&gt;right rotation 是为了应对这种情况:  &lt;br /&gt;
&lt;img alt="" src="algoI_week5_1/pasted_image024.png" /&gt; rotateRight(c) ⇒ &lt;img alt="" src="algoI_week5_1/pasted_image023.png" /&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;color-flip&lt;/strong&gt; &lt;br /&gt;
(split a 4-node, with three kyes — two red links) &lt;br /&gt;
&lt;img alt="" src="algoI_week5_1/pasted_image017.png" /&gt;  &lt;img alt="" src="algoI_week5_1/pasted_image018.png" /&gt;   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;filpColor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   
    &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;RED&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;BLACK&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;BLACK&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Implementation&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Basic strategy&lt;/strong&gt; &lt;br /&gt;
Maintain &lt;em&gt;one-to-one correspondence&lt;/em&gt; with 2-3 tree by applying elementary operations.    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;search&lt;/strong&gt;   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;Exactly&lt;/em&gt; the same as elementary BST. ( ⇒ The same code for floor and ceiling)   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;insert&lt;/strong&gt;   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Each insert will generate a red link&lt;/strong&gt; (then should rotate to make it legal)   &lt;/p&gt;
&lt;p&gt;插入的时候有两种可能:    &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;insert into a 2-node at the bottom   &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week5_1/pasted_image025.png" /&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;standart BST insert   &lt;/li&gt;
&lt;li&gt;if have red right link: rotateLeft   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ex:  &lt;br /&gt;
&lt;img alt="" src="algoI_week5_1/pasted_image021.png" /&gt;   &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;insert into a 3-node    &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有三种可能: insert into left/middle/right, right最简单, left捎复杂, middle最复杂, 见下图:  &lt;br /&gt;
&lt;img alt="" src="algoI_week5_1/pasted_image026.png" /&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;standard BST insert and color nodes   &lt;/li&gt;
&lt;li&gt;if necessary, rotate to balance 4-node, 比如:    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week5_1/pasted_image031.png" /&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;flip colors to pass red link to upper level   &lt;/li&gt;
&lt;li&gt;if necessary, rotate to make all links left-leaning    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ex: &lt;br /&gt;
&lt;img alt="" src="algoI_week5_1/pasted_image032.png" /&gt; &lt;br /&gt;
ex2: &lt;br /&gt;
&lt;img alt="" src="algoI_week5_1/pasted_image033.png" /&gt;    &lt;/p&gt;
&lt;p&gt;视频最后一段的demo太帅了! 叹为观止!!   &lt;/p&gt;
&lt;h2&gt;Code&lt;/h2&gt;
&lt;p&gt;原来&lt;strong&gt;只有4种(其实是3种)情况要调整&lt;/strong&gt;:    &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;left = black, right = red&lt;/em&gt;   &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week5_1/pasted_image034.png" /&gt;  ⇒ rotateLeft(a)   &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;left =red, left.right = red [这个不会出现, 因为这对于下一层来说是case 1..]&lt;/em&gt;   &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week5_1/pasted_image039.png" /&gt;  ⇒ rotateLeft(e) ⇒ 变为case 3    &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;left = red, left.left = red&lt;/em&gt;   &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week5_1/pasted_image035.png" /&gt;  ⇒ rotateRight(s) ⇒ 变为case 4   &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;left = red. right = red&lt;/em&gt;   &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week5_1/pasted_image036.png" /&gt;      ⇒ flipColor(r)   &lt;/p&gt;
&lt;p&gt;几个状态之间的转化:  &lt;br /&gt;
&lt;img alt="" src="algoI_week5_1/pasted_image038.png" /&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;只要三行代码即可处理LLRB tree !! 老爷子牛逼...... &lt;/strong&gt; &lt;br /&gt;
(这个也是在2007年algo第四版的时候才刚刚弄出来的, 以前的代码要复杂)   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="nf"&gt;put&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Value&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;RED&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;cmp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;compareTo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cmp&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 这里不急着返回 -- same trick as for BSTs..   &lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cmp&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;put&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;put&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
    &lt;span class="c1"&gt;// modifications to maintain LLRB tree property:    &lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;isRed&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;isRed&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;rotateLeft&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//case 1   &lt;/span&gt;
    &lt;span class="c1"&gt;//if( isRed(nd.left) &amp;amp;&amp;amp; isRed(nd.left.right) ) nd.left = rotateLeft(nd.left);// case 2 -- never happen...   &lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;isRed&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;isRed&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;rotateRight&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;// case 3   &lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;isRed&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;isRed&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;flipColor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//case 4   &lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这三行代码越看越精妙......    &lt;/p&gt;
&lt;h2&gt;Analysis&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week5_1/pasted_image041.png" /&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;worst case&lt;/strong&gt;: the left path is &lt;em&gt;alternating red and black&lt;/em&gt;. &lt;br /&gt;
⇒ longest path &amp;lt;= 2 * shortest path  (height&amp;lt;= 2lgN)   &lt;/p&gt;
&lt;p&gt;practical applications: height ~ 1.0 lgN   &lt;/p&gt;
&lt;p&gt;summery:  &lt;br /&gt;
&lt;img alt="" src="algoI_week5_1/pasted_image042.png" /&gt;   &lt;/p&gt;
&lt;h1&gt;3. B-trees&lt;/h1&gt;
&lt;p&gt;setting: data access in file system.  &lt;br /&gt;
&lt;em&gt;Probe is much expensive than accessing data within a page.&lt;/em&gt;    &lt;/p&gt;
&lt;p&gt;Goal: access data using a minimum number of probes.   &lt;/p&gt;
&lt;h2&gt;B-tree&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;def.&lt;/strong&gt; &lt;br /&gt;
external nodes: contain just keys, not links &lt;br /&gt;
internal nodes: contain key-link pairs   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;def. B-tree&lt;/strong&gt; &lt;br /&gt;
Generalize 2-3 trees by allowing up to M-1 keys per node:   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;= 2 keys in root   &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;= M/2 keys in other nodes   &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;external nodes contain client keys   &lt;/li&gt;
&lt;li&gt;internal nodes contain copies of keys to guide search   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week5_1/pasted_image043.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;Searching&lt;/h2&gt;
&lt;p&gt;similar to BST/2-3tree &lt;br /&gt;
ex. &lt;br /&gt;
&lt;img alt="" src="algoI_week5_1/pasted_image044.png" /&gt;   &lt;/p&gt;
&lt;p&gt;(Choose M as large as possible so that M links fit into a page)   &lt;/p&gt;
&lt;h2&gt;Insertion&lt;/h2&gt;
&lt;p&gt;similar to 2-3 tree &lt;br /&gt;
&lt;img alt="" src="algoI_week5_1/pasted_image045.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;Analysis&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week5_1/pasted_image046.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;System implementations&lt;/h2&gt;
&lt;p&gt;system implementations of RBtree. &lt;br /&gt;
java:  &lt;br /&gt;
&lt;code&gt;java.util.TreeMap&lt;/code&gt;, &lt;code&gt;java.util.TreeSet&lt;/code&gt;.   &lt;/p&gt;
&lt;p&gt;八卦1: &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week5_1/pasted_image047.png" /&gt;     &lt;/p&gt;
&lt;p&gt;八卦2: 
Sedgewick 的朋友, &lt;a href="https://fr.wikipedia.org/wiki/Philippe_Flajolet"&gt;Philippe Flajolet&lt;/a&gt;, 是一个X!    &lt;/p&gt;</summary><category term="algorithm"></category></entry><entry><title>[Algorithms I] Week 4-2b Binary Search Trees</title><link href="http://x-wei.github.io/algoI_week4_2b.html" rel="alternate"></link><updated>2015-08-26T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/algoI_week4_2b.html</id><summary type="html">&lt;p&gt;(BST是锻炼递归代码的好题目)   &lt;/p&gt;
&lt;h1&gt;1. Binary Search Trees&lt;/h1&gt;
&lt;p&gt;def. &lt;strong&gt;BST&lt;/strong&gt; &lt;br /&gt;
A binary tree where each node has a key:  &lt;br /&gt;
for every node, the key is larger than &lt;em&gt;all nodes in left&lt;/em&gt; subtree, smaller than &lt;em&gt;all nodes in right&lt;/em&gt; subtree.  &lt;br /&gt;
&lt;img alt="" src="algoI_week4_2b/pasted_image.png" /&gt; &lt;br /&gt;
Fields: key, val, left, right   &lt;/p&gt;
&lt;h2&gt;Implementation&lt;/h2&gt;
&lt;p&gt;An inner class of BST nodes:    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;   
    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;Value&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Key&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Value&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;){...}&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;skeleton implementation of BST:    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;BST&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;Key&lt;/span&gt; &lt;span class="nx"&gt;implements&lt;/span&gt; &lt;span class="nx"&gt;Comparable&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;Key&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;Value&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;   
&lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="nf"&gt;Node&lt;/span&gt; &lt;span class="nb"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
&lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="nf"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nx"&gt;...&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;   
&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;Value&lt;/span&gt; &lt;span class="nb"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;Key&lt;/span&gt; &lt;span class="nx"&gt;k&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="nx"&gt;...&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;   
&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;put&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;Key&lt;/span&gt; &lt;span class="nx"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;Value&lt;/span&gt; &lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="p"&gt;){}&lt;/span&gt;   
&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;void&lt;/span&gt; &lt;span class="nb"&gt;delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;Key&lt;/span&gt; &lt;span class="nx"&gt;k&lt;/span&gt;&lt;span class="p"&gt;){}&lt;/span&gt;   
&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;Iterable&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;Key&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;iterator&lt;/span&gt;&lt;span class="p"&gt;(){}&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;search&lt;/strong&gt; &lt;br /&gt;
recursive version:  &lt;br /&gt;
(或者把这个函数写到Node类里面也可以. )   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;Value&lt;/span&gt; &lt;span class="nf"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// search miss   &lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;cmp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;compareTo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cmp&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// search hit   &lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cmp&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;non-recursive version:   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Value&lt;/span&gt; &lt;span class="nf"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Key&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   
    &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;cmp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;compareTo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cmp&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cmp&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;insert&lt;/strong&gt; &lt;br /&gt;
recursive version:  &lt;br /&gt;
(注意这个recursive函数的返回值不是void! 这里是一个trick: 返回的是在分叉以前的那个节点)   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="nf"&gt;put&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Value&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;cmp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;compareTo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cmp&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cmp&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;put&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;put&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;non-recursive version: &lt;br /&gt;
不如递归版本优美...   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;put&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Key&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Value&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   
    &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;cmp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;compareTo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cmp&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;   
            &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
        &lt;span class="p"&gt;}&lt;/span&gt;   
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cmp&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;    
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;   
        &lt;span class="p"&gt;}&lt;/span&gt;   
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;    
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;   
        &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="p"&gt;}&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Analysis&lt;/h2&gt;
&lt;p&gt;complexity: depth of the BST.    &lt;/p&gt;
&lt;p&gt;shape of BST: depends on how the keys come in (order of insertion).  &lt;br /&gt;
&lt;img alt="" src="algoI_week4_2b/pasted_image001.png" /&gt; &lt;br /&gt;
if keys come in &lt;em&gt;random&lt;/em&gt; order: could be pretty well balanced.    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BST and quick-sort partitionning&lt;/strong&gt; &lt;br /&gt;
&lt;em&gt;The root of BST is just the pivot in quick sort partitioning  * &lt;br /&gt;
if all keys are distinct ⇒ one-to-one correspondence between quick sort and BST.  &lt;br /&gt;
&lt;img alt="" src="algoI_week4_2b/pasted_image002.png" /&gt;  &lt;br /&gt;
⇒ &lt;strong&gt;proposition&lt;/strong&gt; &lt;br /&gt;
if all keys are distinct and come in randome order, the average number of compares for a search/insert is ~2lnN (or 1.39lgN).  &lt;br /&gt;
&lt;/em&gt;proof.* &lt;br /&gt;
证明见quicksort那里的数学推导...    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;proposition &lt;/strong&gt;(Reed, 2003) &lt;br /&gt;
N distinct keys come in random order, average tree height = 4.300lnN   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Worst-case:&lt;/strong&gt; &lt;br /&gt;
The tree becomes just like a linked list: ~N for insertion and search   &lt;/p&gt;
&lt;h1&gt;2. Oredered Operations in BST&lt;/h1&gt;
&lt;p&gt;task: ordered opeartions   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;min()/max()&lt;/code&gt;: min/max key   &lt;/li&gt;
&lt;li&gt;&lt;code&gt;deleteMin()/deleteMax()&lt;/code&gt;   &lt;/li&gt;
&lt;li&gt;&lt;code&gt;floor(Key k)/ceiling(Key k)&lt;/code&gt;: largest key &amp;lt;=k / smallest key &amp;gt;=k   &lt;/li&gt;
&lt;li&gt;&lt;code&gt;rank(Key k)&lt;/code&gt;: nb of keys &amp;lt; key   &lt;/li&gt;
&lt;li&gt;&lt;code&gt;select(int i)&lt;/code&gt;: key with rank=i   &lt;/li&gt;
&lt;li&gt;&lt;code&gt;Iterator&amp;lt;Key&amp;gt; keys(lo, hi)&lt;/code&gt;: iterates through [lo, hi]   &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;min/max&lt;/h2&gt;
&lt;p&gt;easy &lt;br /&gt;
min: left-most &lt;br /&gt;
max: right-most &lt;br /&gt;
&lt;img alt="" src="algoI_week4_2b/pasted_image003.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;floor/ceiling&lt;/h2&gt;
&lt;p&gt;a little more complexed...    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;floor (ceiling is similar)&lt;/strong&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if k==nd.key   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;return nd.val   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if k&amp;lt;nd.key   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;the floor &lt;em&gt;must&lt;/em&gt; be in the left subtree   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if k&amp;gt;nd.key   &lt;ul&gt;
&lt;li&gt;如果min(nd.right) &amp;gt; k: 返回nd.val   &lt;/li&gt;
&lt;li&gt;如果min(nd.right) &amp;lt;= k: go to right   &lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Value&lt;/span&gt; &lt;span class="nf"&gt;floor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="c1"&gt;// largest element with key &amp;lt;= k       &lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;cmp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;compareTo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;         
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cmp&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//case 1   &lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cmp&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;floor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//case 2   &lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;null&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;min&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;compareTo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//case 3   &lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
&lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;floor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;他提供的版本和我写的不一样: 递归函数floor返回的也是一个Node:  &lt;br /&gt;
&lt;img alt="" src="algoI_week4_2b/pasted_image004.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;rank/select&lt;/h2&gt;
&lt;p&gt;In each node, store the number of nodes in the subtree: &lt;em&gt;add an extra field&lt;/em&gt;.   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;size&lt;/strong&gt;   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;   
    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="c1"&gt;//...   &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;    
&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;   
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;   
&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;// this is why we do not put size() inside the class Node!   &lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;   
&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;put&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Value&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   
    &lt;span class="c1"&gt;//.....   &lt;/span&gt;
    &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//maintain count for each node   &lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;rank&lt;/strong&gt; &lt;br /&gt;
(return nb of keys &amp;lt; k)   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if nd.key==k   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;return size(nd.left)   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if nd.key&amp;gt;k   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;return rank(nd.left, k)   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if nd.key&amp;lt;k   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;return size(nd.left)+1+rank(nd,right, k)   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;rank&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//remember null case   &lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;cmp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;compareTo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cmp&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cmp&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;rank&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;rank&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;select() similar...   &lt;/p&gt;
&lt;h2&gt;iteration&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Inorder traversal 中序遍历&lt;/strong&gt;   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;Iterable&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;Key&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;keys&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;   
    &lt;span class="nb"&gt;Queue&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;Key&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;new&lt;/span&gt; &lt;span class="nb"&gt;Queue&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;Key&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;   
    &lt;span class="nx"&gt;inorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;root&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;q&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;    
&lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="nf"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;inorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;Node&lt;/span&gt; &lt;span class="nx"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;Queue&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;Key&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;q&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;nd&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="kt"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="nx"&gt;inorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;nd.left&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
    &lt;span class="nx"&gt;q.enqueue&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;nd.key&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
    &lt;span class="nx"&gt;inorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;nd.right&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="" src="algoI_week4_2b/pasted_image005.png" /&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;property&lt;/strong&gt; &lt;br /&gt;
inorder-traversal gives the keys &lt;em&gt;in ascending order&lt;/em&gt;.  &lt;br /&gt;
(proof by induction)   &lt;/p&gt;
&lt;h1&gt;3. Deletions in BST&lt;/h1&gt;
&lt;p&gt;one final function to implement: delete(Key k), deleteMin(), deleteMax() &lt;br /&gt;
→ and remember to update the count field...   &lt;/p&gt;
&lt;p&gt;(感觉这篇文章其实就讲的很清楚了: &lt;a href="http://www.algolist.net/Data_structures/Binary_search_tree/Removal"&gt;http://www.algolist.net/Data_structures/Binary_search_tree/Removal&lt;/a&gt;   这个在递归函数里使用了parent这个参数)   &lt;/p&gt;
&lt;h2&gt;lazy approch&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;put(k, null)&lt;/code&gt;, and leave the key in the tree (tombstone) &lt;br /&gt;
→ not good if have large number of tombstons...    &lt;/p&gt;
&lt;h2&gt;deleteMin/Max&lt;/h2&gt;
&lt;p&gt;go the the left-most node → replace it with its right node.  &lt;br /&gt;
Recusive function with the &lt;em&gt;returning-node trick&lt;/em&gt;:    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="nf"&gt;deleteMin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// this might not happen   &lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;deleteMin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
    &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//remember to maintain the count field   &lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个递归的技巧又一次使用了.   &lt;/p&gt;
&lt;h2&gt;Hibbard deletion&lt;/h2&gt;
&lt;p&gt;first find node with the key to delete, 3 cases:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0 children:    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;simply set parent link to null &lt;br /&gt;
&lt;img alt="" src="algoI_week4_2b/pasted_image006.png" /&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 child:    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;replace parent link with the child &lt;br /&gt;
&lt;img alt="" src="algoI_week4_2b/pasted_image007.png" /&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2 children (most subtle)&lt;/strong&gt;   &lt;ul&gt;
&lt;li&gt;first replace node key with smallest key in right subtree   &lt;/li&gt;
&lt;li&gt;remove the smallest key in right subtree   &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week4_2b/pasted_image008.png" /&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;code of Hibbard deletion&lt;/strong&gt; &lt;br /&gt;
Again (for the 3rd time) use the &lt;em&gt;return-nd trick&lt;/em&gt;...   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="nf"&gt;delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;// search miss   &lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;cmp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;compareTo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cmp&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cmp&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;   
        &lt;span class="c1"&gt;//if nd is the node to delete   &lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
        &lt;span class="n"&gt;Key&lt;/span&gt; &lt;span class="n"&gt;k2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;min&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
        &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;k2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
        &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;k2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
    &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;    
&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Key&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   
    &lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;感觉用了recursive return-nd 这个trick的实现很漂亮.... 比那篇博客里放一个参数进递归函数以及用auxroot的办法要好不少...    &lt;/p&gt;
&lt;h2&gt;Analysis&lt;/h2&gt;
&lt;p&gt;problem: &lt;em&gt;not symmetric&lt;/em&gt; &lt;br /&gt;
If random insert and delete for a while ⇒ tree become much less balanced ! Tree height tend to be sqrt(N).    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;summery&lt;/strong&gt; &lt;br /&gt;
BST is much better in average case, but not guaranteed for worst case.  &lt;br /&gt;
&lt;img alt="" src="algoI_week4_2b/pasted_image009.png" /&gt;   &lt;/p&gt;</summary><category term="algorithm"></category></entry><entry><title>[Algorithms I] Week 4-2a Elementry Symbol Tables</title><link href="http://x-wei.github.io/algoI_week4_2a.html" rel="alternate"></link><updated>2015-08-25T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/algoI_week4_2a.html</id><summary type="html">&lt;h1&gt;1. Symbol Table API&lt;/h1&gt;
&lt;p&gt;key-value pair abstraction    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;insert&lt;/strong&gt; a value with a key   &lt;/li&gt;
&lt;li&gt;given a key, &lt;strong&gt;search&lt;/strong&gt; for its value   &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Association array abstraction&lt;/h2&gt;
&lt;p&gt;Associate a value to a key — generalized array: &lt;em&gt;a[key]=val&lt;/em&gt;.    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;ST&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;Key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;Value&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;   
    &lt;span class="bp"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;put&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;Key&lt;/span&gt; &lt;span class="nx"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;Value&lt;/span&gt; &lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//remove key if value=null   &lt;/span&gt;
    &lt;span class="nb"&gt;Value&lt;/span&gt; &lt;span class="nb"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;Key&lt;/span&gt; &lt;span class="nx"&gt;k&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//return null if key is absent   &lt;/span&gt;
    &lt;span class="bp"&gt;void&lt;/span&gt; &lt;span class="nb"&gt;delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;Key&lt;/span&gt; &lt;span class="nx"&gt;k&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
    &lt;span class="nb"&gt;boolean&lt;/span&gt; &lt;span class="nb"&gt;contains&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;Key&lt;/span&gt; &lt;span class="nx"&gt;k&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
    &lt;span class="nb"&gt;boolean&lt;/span&gt; &lt;span class="nb"&gt;isEmpty&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;   
    &lt;span class="nx"&gt;int&lt;/span&gt; &lt;span class="nb"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;   
    &lt;span class="nx"&gt;Iterable&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;Key&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;keys&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="c1"&gt;//better to return an ordered sequence of keys   &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;conventions:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;values are not null   &lt;/li&gt;
&lt;li&gt;get() returns null if key not present   &lt;/li&gt;
&lt;li&gt;put() can &lt;em&gt;overwrite&lt;/em&gt; older value   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;→ some one-line implementations:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;contains: &lt;code&gt;return get(k)!=null;&lt;/code&gt;   &lt;/li&gt;
&lt;li&gt;delete: &lt;code&gt;put(k, null);&lt;/code&gt;   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Assume keys to be comparable: &lt;code&gt;class ST&amp;lt;Key implements Comparable&amp;lt;Key&amp;gt;, Value&amp;gt;&lt;/code&gt;— can thus use &lt;code&gt;compareTo()&lt;/code&gt; method.  &lt;br /&gt;
Else →  we can only use the &lt;code&gt;equals()&lt;/code&gt; method...  &lt;br /&gt;
Be careful when implementing the equals method: 坑不少...  &lt;br /&gt;
&lt;img alt="" src="algoI_week4_2a/pasted_image.png" /&gt;   &lt;/p&gt;
&lt;h1&gt;2. Elementary implementations&lt;/h1&gt;
&lt;p&gt;naive implementations   &lt;/p&gt;
&lt;h2&gt;using unordered linked list&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;ListNode{key, value, next}&lt;/em&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;search: scan through all keys ~N   &lt;/li&gt;
&lt;li&gt;insert: scan through, if not found, add to front ~N   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week4_2a/pasted_image001.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;using ordered array&lt;/h2&gt;
&lt;p&gt;using 2 arrays: &lt;em&gt;keys[] (sorted), vals[]&lt;/em&gt; &lt;br /&gt;
⇒ can improve performance by binary search   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;search operation&lt;/strong&gt; &lt;br /&gt;
write a function rank() that returns the number of keys &amp;lt; k searched.  &lt;br /&gt;
找不到的时候: &lt;em&gt;比k小的元素个数=lo (lo&amp;gt;hi, 可以想想当hi=lo以后是怎么移动的)&lt;/em&gt;   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;rank&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Key&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;keys&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lo&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;cmp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;keys&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;compareTo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;keys&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;   
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cmp&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cmp&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;hi&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;lo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Using rank() to implement the get() method:    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Value&lt;/span&gt; &lt;span class="nf"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Key&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;rk&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;rank&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rk&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;keys&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rk&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;compareTo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;vals&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rk&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;   
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;insert operation&lt;/strong&gt; &lt;br /&gt;
Like insertion sort, time complexity is ~N for each insert.    &lt;/p&gt;
&lt;p&gt;summery:  &lt;br /&gt;
&lt;img alt="" src="algoI_week4_2a/pasted_image002.png" /&gt;   &lt;/p&gt;
&lt;h1&gt;3. Ordered Opeartions&lt;/h1&gt;
&lt;p&gt;When keys are comparable ⇒ provide &lt;em&gt;more functionalities&lt;/em&gt; in the API.  &lt;br /&gt;
for example:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;min()/max()&lt;/code&gt;: min/max key   &lt;/li&gt;
&lt;li&gt;&lt;code&gt;deleteMin()/deleteMax()&lt;/code&gt;   &lt;/li&gt;
&lt;li&gt;&lt;code&gt;floor(Key k)/ceiling(Key k)&lt;/code&gt;: largest key &amp;lt;=k / smallest key &amp;gt;=k   &lt;/li&gt;
&lt;li&gt;&lt;code&gt;rank(Key k)&lt;/code&gt;: nb of keys &amp;lt; key   &lt;/li&gt;
&lt;li&gt;&lt;code&gt;select(int i)&lt;/code&gt;: key with rank=i   &lt;/li&gt;
&lt;li&gt;&lt;code&gt;Iterator&amp;lt;Key&amp;gt; keys(lo, hi)&lt;/code&gt;: iterates through [lo, hi]   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week4_2a/pasted_image004.png" /&gt;   &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week4_2a/pasted_image003.png" /&gt;   &lt;/p&gt;</summary><category term="algorithm"></category></entry><entry><title>[Algorithms I] Week 4-1 Priority Queue</title><link href="http://x-wei.github.io/algoI_week4_1.html" rel="alternate"></link><updated>2015-08-24T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/algoI_week4_1.html</id><summary type="html">&lt;h1&gt;1. API and elementary implementations&lt;/h1&gt;
&lt;p&gt;Collection: data struct for inserting and deleting items (ex. stack and queue).  &lt;br /&gt;
Priority queue: a special kind of collection — remove &lt;em&gt;largest/smallest&lt;/em&gt; element.    &lt;/p&gt;
&lt;p&gt;API:    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;class&lt;/span&gt; &lt;span class="k"&gt;Max&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;Kye&lt;/span&gt; &lt;span class="nx"&gt;implements&lt;/span&gt; &lt;span class="nx"&gt;Comparable&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;Key&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;   
    &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;MaxPQ&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;    
    &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;void&lt;/span&gt; &lt;span class="nb"&gt;insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="na"&gt;Key&lt;/span&gt; &lt;span class="nx"&gt;k&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
    &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;Key&lt;/span&gt; &lt;span class="nx"&gt;delMax&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;    
    &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;boolean&lt;/span&gt; &lt;span class="nb"&gt;isEmpty&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;     
    &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;Key&lt;/span&gt; &lt;span class="k"&gt;max&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;   
    &lt;span class="nx"&gt;int&lt;/span&gt; &lt;span class="nb"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;PQ client example&lt;/h2&gt;
&lt;p&gt;find &lt;em&gt;M largest&lt;/em&gt; elements from N items. (N is too huge to store) &lt;br /&gt;
⇒ 思路: 用 &lt;strong&gt;Min&lt;/strong&gt;&lt;em&gt;PQ&lt;/em&gt;, 当size&amp;gt;M时删掉最小元素 — 最后剩下的就是最大的M个元素了.  &lt;br /&gt;
&lt;img alt="" src="algoI_week4_1/pasted_image.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;elementary(naive) implementations&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;unordered array implementation&lt;/strong&gt; &lt;br /&gt;
insert ~1,  &lt;br /&gt;
remove ~N   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ordered array implementation&lt;/strong&gt; &lt;br /&gt;
insert ~N — ~ insertion sort, &lt;br /&gt;
remove ~1   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;goal&lt;/strong&gt;:  &lt;br /&gt;
insert O(lgN) &amp;amp; remove max O(lgN)   &lt;/p&gt;
&lt;h1&gt;2. Binary Heaps&lt;/h1&gt;
&lt;p&gt;binary heap: a special kind of &lt;em&gt;complete binary tree&lt;/em&gt;.    &lt;/p&gt;
&lt;p&gt;def. "&lt;strong&gt;complete binary tree"&lt;/strong&gt; &lt;br /&gt;
All level except the last level are full, all nodes in the last level are as far left as possible.   &lt;br /&gt;
完全二叉树大概长这个样子:  &lt;br /&gt;
&lt;img alt="" src="algoI_week4_1/pasted_image001.png" /&gt;   &lt;/p&gt;
&lt;p&gt;property: a complete binary tree with N items has height = lgN.    &lt;/p&gt;
&lt;p&gt;def. &lt;strong&gt;binary heap&lt;/strong&gt; &lt;br /&gt;
Binary heap is a complete binary tree that satisfies: &lt;em&gt;each node &amp;gt;= any of its 2 children&lt;/em&gt; ("heap ordering").    &lt;/p&gt;
&lt;p&gt;property of binary heap:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;max element is root   &lt;/li&gt;
&lt;li&gt;height is lgN   &lt;/li&gt;
&lt;li&gt;&lt;em&gt;each node still makes a heap&lt;/em&gt; (use this property to construct heap from bottom up)   &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Array representation of binary heap&lt;/h2&gt;
&lt;p&gt;Use an array &lt;code&gt;a[]&lt;/code&gt; to represent a complete binary tree: very easy to get children and parent.    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;index starting from 1&lt;/strong&gt; (root = a[1], do not use a[0])    &lt;/li&gt;
&lt;li&gt;for node at index &lt;code&gt;i&lt;/code&gt;, its children are: &lt;code&gt;i*2&lt;/code&gt; and &lt;code&gt;i*2+1&lt;/code&gt;   &lt;/li&gt;
&lt;li&gt;for node at index &lt;code&gt;i&lt;/code&gt; (i&amp;gt;1), its parent is: &lt;code&gt;i/2&lt;/code&gt;   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week4_1/pasted_image002.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;Implementation&lt;/h2&gt;
&lt;p&gt;简言之就是:  &lt;br /&gt;
&lt;img alt="" src="algoI_week4_1/pasted_image003.png" /&gt;   &lt;/p&gt;
&lt;p&gt;内部成员变量:    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;MaxPQ&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;Key&lt;/span&gt; &lt;span class="nx"&gt;implements&lt;/span&gt; &lt;span class="nx"&gt;Comparable&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;Key&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;   
    &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="nf"&gt;Key&lt;/span&gt;&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; a;   
    private int N;   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;siftup (swim)&lt;/strong&gt; &lt;br /&gt;
if a node is larger than its parent: &lt;em&gt;exchange with parent until heap ordering is restored.&lt;/em&gt;    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;swim&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;less&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;]){&lt;/span&gt;   
        &lt;span class="n"&gt;exch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
        &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;/=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="p"&gt;}&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;⇒ &lt;strong&gt;use siftup for inserting elements&lt;/strong&gt; &lt;br /&gt;
when inserting an element, first append it to the end of the array, then siftup the element to its right position.    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Key&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;    
&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
&lt;span class="n"&gt;swim&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;siftdown (sink)&lt;/strong&gt; &lt;br /&gt;
if a node is smaller than its children: &lt;em&gt;exchange it with the bigger child.&lt;/em&gt; 用公司高层变动来类比很形象...    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;sink&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;maxIndex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;less&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;less&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;maxIndex&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="n"&gt;maxIndex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;maxIndex&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
        &lt;span class="n"&gt;exch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;maxIndex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
        &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;maxIndex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="p"&gt;}&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;⇒ use siftdown for deleting max operation&lt;/strong&gt; &lt;br /&gt;
First put a[N] to the position of root, then sink. (注意要防止loitering)   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt; &lt;span class="nf"&gt;delMax&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;   
    &lt;span class="n"&gt;Key&lt;/span&gt; &lt;span class="n"&gt;ret&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;   
    &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;   
    &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// avoid loitering   &lt;/span&gt;
    &lt;span class="n"&gt;sink&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;ret&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Analysis&lt;/h2&gt;
&lt;p&gt;insert: ~lgN &lt;br /&gt;
remove max: ~lgN   &lt;/p&gt;
&lt;p&gt;improvements:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;use a &lt;strong&gt;d-way heap&lt;/strong&gt; instead of a 2-way heap (for ex. 3-way heap, the children of i are i&lt;em&gt;3, i&lt;/em&gt;3+1, i*3+2, the parent of i is i/3)   &lt;/li&gt;
&lt;li&gt;Fibonacci heap: insert is &lt;em&gt;~1&lt;/em&gt;, remove max still ~lgN, (but too complicated to use in practice).    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week4_1/pasted_image004.png" /&gt;   &lt;/p&gt;
&lt;p&gt;considerations:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;use immutable keys to avoid client from changing the keys (&lt;code&gt;final&lt;/code&gt; keyword in java)   &lt;/li&gt;
&lt;li&gt;underflow/overflow: throw exceptions for delMax() when empty, use resizing array for implementation.   &lt;/li&gt;
&lt;li&gt;expand the API with other operations: remove an arbitrary item, change the prority of an item (like handling an array)...   &lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;3. Heapsort&lt;/h1&gt;
&lt;p&gt;Basic idea:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;create a max heap with all N entries &lt;strong&gt;("heap-construction")&lt;/strong&gt;   &lt;/li&gt;
&lt;li&gt;then repeatedly remove all N items &lt;strong&gt;("sortdown")&lt;/strong&gt;   &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Implementation&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;heap construction&lt;/strong&gt;  &lt;br /&gt;
Construct the heap using a &lt;strong&gt;bottom-up&lt;/strong&gt; method: build the heaps with small size first.    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;one-node heaps (jus leaf node of heap): need not consider   &lt;/li&gt;
&lt;li&gt;larger heaps: children(subtrees) are already heap-order → just perform sink operation for root   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;⇒ &lt;em&gt;sink elements at indices from N/2 to 1&lt;/em&gt;   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   
&lt;span class="n"&gt;sink&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;→ complexity is &lt;strong&gt;linear&lt;/strong&gt;, see analysis below.    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;heap destruction &lt;/strong&gt; &lt;br /&gt;
now that we have a max-heap, to get the sorted array &lt;em&gt;in-place,&lt;/em&gt; simply do:    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   
&lt;span class="n"&gt;exch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
&lt;span class="n"&gt;sink&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Analysis&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;proposition&lt;/strong&gt; &lt;br /&gt;
Heap construction uses &lt;strong&gt;&amp;lt;2N&lt;/strong&gt; compares and exchanges.  &lt;br /&gt;
&lt;em&gt;proof&lt;/em&gt; &lt;br /&gt;
一个有h层的heap, 高度为k的subtree有 2^(h-k)个, 每个subtree最多可以交换k次(从root交换到最底层)  &lt;br /&gt;
→ 每一层最多有 k*2^(h-k) 次交换  &lt;br /&gt;
&lt;img alt="" src="algoI_week4_1/pasted_image007.png" /&gt;   &lt;br /&gt;
(第一个等式可以用数学归纳法证...)  &lt;br /&gt;
&lt;a href=""&gt;详细证明见http://algs4.cs.princeton.edu/24pq/&lt;/a&gt;  (Q20答案)   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;proposition&lt;/strong&gt; &lt;br /&gt;
Heapsort use &amp;lt; 2NlgN compares and exchanges.    &lt;/p&gt;
&lt;p&gt;Heapsort is the first &lt;em&gt;in-place&lt;/em&gt; sorting algorithm with NlgN &lt;em&gt;worst-case&lt;/em&gt; performance.  &lt;br /&gt;
&lt;img alt="" src="algoI_week4_1/pasted_image005.png" /&gt;   &lt;/p&gt;
&lt;p&gt;⇒ heapsort is &lt;em&gt;optimal for time and space&lt;/em&gt;, but:   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;inner loop is longer than quicksort   &lt;/li&gt;
&lt;li&gt;poor use of cache memory (too many references to cache — look far away from the array entry when going down through the tree)   &lt;/li&gt;
&lt;li&gt;not stable: because it does long-distance exchanges   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Summary:  &lt;br /&gt;
&lt;img alt="" src="algoI_week4_1/pasted_image006.png" /&gt;   &lt;/p&gt;
&lt;h1&gt;4. Event-driven simulation&lt;/h1&gt;
&lt;p&gt;Goal: simulating the motion of N particles in elastic collision (using a priority queue).  &lt;br /&gt;
&lt;img alt="" src="algoI_week4_1/pasted_image008.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;model&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week4_1/pasted_image009.png" /&gt; &lt;br /&gt;
bouncing balls (without collision) &lt;br /&gt;
&lt;img alt="" src="algoI_week4_1/pasted_image010.png" /&gt;    &lt;/p&gt;
&lt;p&gt;Ball class:  &lt;br /&gt;
&lt;img alt="" src="algoI_week4_1/pasted_image011.png" /&gt;   &lt;/p&gt;
&lt;p&gt;challenge: which objects to check? How to do it efficently ?   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Time driven simulation&lt;/strong&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;upate the position of balls every &lt;code&gt;dt&lt;/code&gt; seconds   &lt;/li&gt;
&lt;li&gt;if overlap detected: figure how the velocity change and continue the simulation.    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;problem with time-driven simulation:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1/2*N^2 overlap check per time unit   &lt;/li&gt;
&lt;li&gt;if dt small: too much calculation   &lt;/li&gt;
&lt;li&gt;if dt too large: might miss collisions   &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Event driven simulation&lt;/h2&gt;
&lt;p&gt;change state only when something happens   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;particles move in straight line before collision   &lt;/li&gt;
&lt;li&gt;→ collision time can be &lt;em&gt;predicted&lt;/em&gt;   &lt;/li&gt;
&lt;li&gt;maintain PQ for collisions, key=collision time    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;collision prediction&lt;/strong&gt; &lt;br /&gt;
input: each particle has radius &lt;code&gt;s&lt;/code&gt;, position &lt;code&gt;(rx, ry)&lt;/code&gt;, velocity &lt;code&gt;(vx, vy)&lt;/code&gt;. &lt;br /&gt;
&lt;img alt="" src="algoI_week4_1/pasted_image013.png" /&gt; &lt;br /&gt;
&lt;img alt="" src="algoI_week4_1/pasted_image014.png" /&gt;  &lt;br /&gt;
(美国高中物理这么凶残?...)   &lt;/p&gt;
&lt;h2&gt;Implementation&lt;/h2&gt;
&lt;p&gt;anyway, 这个是封装好的类: &lt;br /&gt;
&lt;img alt="" src="algoI_week4_1/pasted_image015.png" /&gt; &lt;br /&gt;
注意, 使用了count记录一个particle到目前为止的碰撞次数.    &lt;/p&gt;
&lt;p&gt;initialization: &lt;strong&gt;quadratic&lt;/strong&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Fill PQ with all &lt;em&gt;potential&lt;/em&gt;  particle-particle collisions   &lt;/li&gt;
&lt;li&gt;Fill (the same) PQ with all &lt;em&gt;potential&lt;/em&gt;  particle-wall collisions   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Main loop &lt;/strong&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;get next event from PQ, event time = t   &lt;/li&gt;
&lt;li&gt;ignore if the event is &lt;em&gt;invalidated&lt;/em&gt;   &lt;/li&gt;
&lt;li&gt;advance all particles to time t   &lt;/li&gt;
&lt;li&gt;update velocities   &lt;/li&gt;
&lt;li&gt;predict future collisions and insert to PQ   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week4_1/pasted_image018.png" /&gt; &lt;br /&gt;
判断invalidate:  &lt;br /&gt;
一个event构造(predict)时记录粒子构造时刻的碰撞次数(countA, countB), &lt;br /&gt;
然后在调用invalidate的时候, 如果粒子的碰撞次数发生了改变, 则返回false.  &lt;br /&gt;
(详见他们的代码: &lt;a href="http://algs4.cs.princeton.edu/61event/CollisionSystem.java.html"&gt;http://algs4.cs.princeton.edu/61event/CollisionSystem.java.html&lt;/a&gt;)   &lt;/p&gt;
&lt;p&gt;Event class:  &lt;br /&gt;
&lt;img alt="" src="algoI_week4_1/pasted_image016.png" /&gt; &lt;br /&gt;
&lt;img alt="" src="algoI_week4_1/pasted_image017.png" /&gt;   &lt;/p&gt;</summary><category term="algorithm"></category></entry><entry><title>[Algorithms I] Week 3-2 Quicksort</title><link href="http://x-wei.github.io/algoI_week3_2.html" rel="alternate"></link><updated>2015-08-22T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/algoI_week3_2.html</id><summary type="html">&lt;p&gt;(maybe best algorithm for sorting.)   &lt;/p&gt;
&lt;h1&gt;1. Quicksort&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Idea:&lt;/strong&gt;     &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;shuffle the array     &lt;/li&gt;
&lt;li&gt;&lt;em&gt;Partition&lt;/em&gt; the array into two subarrays to left and right of pivot  (*now pivot is &lt;strong&gt;*in its final position&lt;/strong&gt;)   &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;no larger entry to the left of pivot   &lt;br /&gt;
no smaller entry to the right of pivot     &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;sort each subarray recursively     &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week3_2/pasted_image.png" /&gt;      &lt;/p&gt;
&lt;h2&gt;Implemetation&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;The partition process:&lt;/strong&gt;    &lt;br /&gt;
这个方法也比较巧妙.  &lt;br /&gt;
Use 2 pointers i and j (个人觉得用hi, lo, pivot更好...) :    &lt;br /&gt;
&lt;img alt="" src="algoI_week3_2/pasted_image001.png" /&gt;    &lt;br /&gt;
→ a[i]&amp;gt;=a[lo], a[j]&amp;lt;&lt;strong&gt;=&lt;/strong&gt;a[lo] (注意是大于&lt;strong&gt;等于&lt;/strong&gt;/小于&lt;strong&gt;等于&lt;/strong&gt;)    &lt;br /&gt;
⇒ exchange i and j    &lt;br /&gt;
→ Scan until i and j cross (ie. j&amp;lt;=i)    &lt;br /&gt;
⇒ finally exchange lo with &lt;strong&gt;j&lt;/strong&gt; &lt;br /&gt;
函数的签名定义的好: 把lo到hi部分的数组分成两部分, 并返回分割点的index.   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;partition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Comparable&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   
        &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="n"&gt;hi&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;less&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//a[i]&amp;gt;=a[lo]   &lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="n"&gt;lo&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;less&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//a[j]&amp;lt;=a[lo]   &lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;exch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
    &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="n"&gt;exch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//exchange pivot with j   &lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//j in its final position   &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个函数其实并不好写对:     &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;test for cross pointers is not trival (ex. edge case: the pivot is the smallest/largest entry in the range)   &lt;/li&gt;
&lt;li&gt;i&amp;lt;=hi is necessary !    &lt;/li&gt;
&lt;li&gt;for keys equal to a[lo]: better to stop at them   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;invariance:    &lt;br /&gt;
&lt;img alt="" src="algoI_week3_2/pasted_image002.png" /&gt;      &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Quicksort:   &lt;/strong&gt; &lt;br /&gt;
使用partition函数和辅助sort函数(recursive).  注意在整个流程开始以前先shuffle一下.     &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Comparable&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;pivot&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;partition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
    &lt;span class="n"&gt;sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;pivot&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
    &lt;span class="n"&gt;sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;pivot&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
    &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;   
&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Comparable&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   
    &lt;span class="n"&gt;StdRandom&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shuffle&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// don&amp;#39;t forget to shuffle the array   &lt;/span&gt;
    &lt;span class="n"&gt;sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The randomness is preserved: the subarrays after partitionning is still randomly ordered.      &lt;/p&gt;
&lt;h2&gt;Analysis&lt;/h2&gt;
&lt;p&gt;Performance: ~40% faster than mergesort.      &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Best case&lt;/strong&gt;   &lt;/p&gt;
&lt;h1&gt;compares = NlgN&lt;/h1&gt;
&lt;p&gt;(each partition will divide the array in half)     &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Worst case  &lt;/strong&gt;   &lt;/p&gt;
&lt;h1&gt;compares = 1/2*N^2&lt;/h1&gt;
&lt;p&gt;N+(N-1)+...+1 &lt;br /&gt;
if the array is already in order, &lt;em&gt;each partition will have one subarray of length=0&lt;/em&gt;     &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Average case  &lt;/strong&gt;   &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;proposition  &lt;/strong&gt; &lt;br /&gt;
On average, for array with N distinct keys, the #compares =  ~2NlnN, #exchanges = ~1/2&lt;em&gt;NlnN.    &lt;br /&gt;
&lt;/em&gt;Proof.*    &lt;br /&gt;
C(N) := # compares for N entries   &lt;br /&gt;
pivot 在N个数离的排名是uniform的    &lt;br /&gt;
接下来的数学推到很漂亮(不过可能没啥用..)     &lt;br /&gt;
&lt;img alt="" src="algoI_week3_2/pasted_image003.png" /&gt;       &lt;br /&gt;
&lt;img alt="" src="algoI_week3_2/pasted_image004.png" /&gt;      &lt;br /&gt;
&lt;img alt="" src="algoI_week3_2/pasted_image006.png" /&gt;         &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(上面最后一行写错了... 是2NlnN...orz)
random shuffle: probalistic guarantee against worst case.    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Pitfalls    &lt;/strong&gt; &lt;br /&gt;
implementations will get &lt;em&gt;quadratic&lt;/em&gt; performance if array:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;is sorted or reverse sorted   &lt;/li&gt;
&lt;li&gt;has many duplicates (even if randomized)   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Staility  &lt;/strong&gt; &lt;br /&gt;
Quicksort is &lt;strong&gt;NOT&lt;/strong&gt; stable.   &lt;br /&gt;
partitionning can make long range exchanges   &lt;br /&gt;
&lt;img alt="" src="algoI_week3_2/pasted_image007.png" /&gt;      &lt;/p&gt;
&lt;h2&gt;Practical improvements&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;cutoff to insertion sort for &amp;lt;10 items    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;→ ~20% improvement    &lt;br /&gt;
Or we can leave the small subarrays unsorted and sort them at last using insertion sort      &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;estimate median by sampling 3 items       &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week3_2/pasted_image008.png" /&gt; &lt;br /&gt;
 → 10% improvement     &lt;/p&gt;
&lt;h1&gt;2. Selection&lt;/h1&gt;
&lt;p&gt;Goal: &lt;em&gt;given un array, find the kth largest item.&lt;/em&gt;    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Upper bound for this problem: NlgN (just sort the array)    &lt;/li&gt;
&lt;li&gt;for small k (ex k=1,2,3), the upper bound is N (one-pass/two-pass)     &lt;/li&gt;
&lt;li&gt;Lower bound is N: at least have to look at everything     &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Quick select&lt;/h2&gt;
&lt;p&gt;Algo proposed also by Hoare:      &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;partition the array into two arrays left of pivot and right of pivot.      &lt;/li&gt;
&lt;li&gt;if pivot==k: return      &lt;/li&gt;
&lt;li&gt;continue the partition for just one of the subarrays       &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;类似于二分查找的过程....  &lt;br /&gt;
注意这里&lt;strong&gt;是不用递归的&lt;/strong&gt;! 因为partition函数返回的直接就是pivot&lt;em&gt;在整个数组里的&lt;/em&gt;位置!    &lt;/p&gt;
&lt;h2&gt;Implementation&lt;/h2&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;privater&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;partition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Comparable&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;){...}&lt;/span&gt;

&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;Comparable&lt;/span&gt; &lt;span class="nf"&gt;select&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Comparable&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   
    &lt;span class="n"&gt;StdRandom&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shuffle&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;partition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;   
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="c1"&gt;//这里不太理解为什么会在hi&amp;lt;lo的时候直接返回a[k]   &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Analysis&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Proposition  &lt;/strong&gt; &lt;br /&gt;
Quick selection takes &lt;strong&gt;linear&lt;/strong&gt; time on average.   &lt;br /&gt;
*proof  * &lt;br /&gt;
intuitively, each partition will ct the subarray size in half:  &lt;br /&gt;
N+N/2+N/4+... = 2N   &lt;br /&gt;
formal analysis 略...   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;worst case&lt;/strong&gt;: quadratic (but very rare to happen)   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Theoretical results&lt;/strong&gt;   &lt;br /&gt;
&lt;img alt="" src="algoI_week3_2/pasted_image009.png" /&gt;         &lt;/p&gt;
&lt;h1&gt;3. Duplicate keys&lt;/h1&gt;
&lt;p&gt;if array contains many duplicate keys.    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;huge array     &lt;/li&gt;
&lt;li&gt;small number of distinct keys     &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;for mergesort  &lt;/strong&gt; &lt;br /&gt;
insensitive... always ~NlgN compares.     &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;for quicksort  &lt;/strong&gt; &lt;br /&gt;
Will get &lt;em&gt;quadratic&lt;/em&gt; time if not stop on equal keys. (found in 1990s)    &lt;br /&gt;
mistake: put all items equal to pivot *to just one side   * &lt;br /&gt;
→ N^2 compares if all keys are equal from lo to hi.  &lt;br /&gt;
correct: put all items equal to pivot in their final place.    &lt;br /&gt;
&lt;img alt="" src="algoI_week3_2/pasted_image010.png" /&gt;      &lt;/p&gt;
&lt;h2&gt;3-way partitionning&lt;/h2&gt;
&lt;p&gt;(by Dijkstra)   &lt;br /&gt;
partition the array into 3 parts:     &lt;br /&gt;
&lt;img alt="" src="algoI_week3_2/pasted_image011.png" /&gt;       &lt;/p&gt;
&lt;p&gt;Dijkstra's 3-way partition algo:  &lt;br /&gt;
使用3个指针: lt指向中间部分的左边界, gt指向右边界;  i指针从左向右扫描, 算法很subtle:     &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lt=lo, gt=hi, i=lo   &lt;/li&gt;
&lt;li&gt;if a[i]==v : i++   &lt;/li&gt;
&lt;li&gt;if a[i]&amp;lt;v: exch(i,lt), i++, lt++   &lt;/li&gt;
&lt;li&gt;if a[i]&amp;gt;v: exch(i,gt), gt--    &lt;/li&gt;
&lt;li&gt;repeat until i and gt cross (i&amp;gt;gt)   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;invariance&lt;/em&gt;&lt;/strong&gt;:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[lo, lt)&lt;/code&gt; &lt;strong&gt;&lt;em&gt;all &amp;lt; v&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[lt, i)&lt;/code&gt; &lt;strong&gt;&lt;em&gt;all == v&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(gt, hi]&lt;/code&gt; &lt;strong&gt;&lt;em&gt;all &amp;gt;v&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week3_2/pasted_image012.png" /&gt;      &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week3_2/pasted_image013.png" /&gt;      &lt;/p&gt;
&lt;h2&gt;Implementation: 3-way quick sort&lt;/h2&gt;
&lt;p&gt;不必再写partition函数, 直接在sort递归函数里面.     &lt;br /&gt;
&lt;img alt="" src="algoI_week3_2/pasted_image014.png" /&gt;        &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Comparable&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 递归函数别忘了先写终止条件...   &lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;lt&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;gt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="n"&gt;Comparable&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;   
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="n"&gt;gt&lt;/span&gt;&lt;span class="p"&gt;;){&lt;/span&gt; &lt;span class="c1"&gt;//不能写 i++   &lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;less&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;   
            &lt;span class="n"&gt;exch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;lt&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;less&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;   
            &lt;span class="n"&gt;exch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;gt&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="c1"&gt;// v==a[i]   &lt;/span&gt;
            &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="n"&gt;sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;lt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
    &lt;span class="n"&gt;sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;gt&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="" src="algoI_week3_2/pasted_image015.png" /&gt;    &lt;br /&gt;
当N个数有很多重复的时候, lower bound可以变小于NlgN:     &lt;br /&gt;
&lt;img alt="" src="algoI_week3_2/pasted_image016.png" /&gt;       &lt;br /&gt;
And Sedgewick proved that the 3-wy partition is propotional to the lower bound....     &lt;br /&gt;
&lt;img alt="" src="algoI_week3_2/pasted_image017.png" /&gt;      &lt;/p&gt;
&lt;h1&gt;4. System Sorts&lt;/h1&gt;
&lt;p&gt;Arrays.sort() in java:   &lt;/p&gt;
&lt;p&gt;&lt;code&gt;import java.util.Arrays;&lt;/code&gt;   &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week3_2/pasted_image018.png" /&gt;    &lt;br /&gt;
quicksort for primitive arrays, mergesort for objects: java设计者认为如果用obj array表示空间不是问题...   &lt;/p&gt;
&lt;p&gt;Pb in java's system sort: killer input exsit (havn't shuffle)...    &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week3_2/pasted_image020.png" /&gt;      &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week3_2/pasted_image021.png" /&gt;      &lt;br /&gt;
总结一下学过的5/6种排序:     &lt;br /&gt;
&lt;img alt="" src="algoI_week3_2/pasted_image022.png" /&gt;      &lt;/p&gt;</summary><category term="algorithm"></category></entry><entry><title>[Algorithms I] Week 3-1 Mergesort</title><link href="http://x-wei.github.io/algoI_week3_1.html" rel="alternate"></link><updated>2015-08-21T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/algoI_week3_1.html</id><summary type="html">&lt;p&gt;Two classical sorting algorithms: mergesort, quicksort.    &lt;/p&gt;
&lt;h1&gt;1. Mergesort&lt;/h1&gt;
&lt;p&gt;Divide and conquer: top 10 algorithms of the 20th century, invented by von Neumann.     &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Idea&lt;/strong&gt;:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;divide array into 2 halves   &lt;/li&gt;
&lt;li&gt;recursively sort each half   &lt;/li&gt;
&lt;li&gt;merge two sorted halves   &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Implementation&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Merge&lt;/strong&gt;:  &lt;br /&gt;
Goal: a[lo] to a[mid] and a[mid+1] to a[hi] are sorted ⇒ get a[lo] to a[hi] sorted.  &lt;br /&gt;
→&lt;em&gt;use an auxiliary array to copy data&lt;/em&gt;: using 3 indices i,j,k.     &lt;br /&gt;
&lt;img alt="" src="algoI_week3_1/pasted_image.png" /&gt;      &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;merge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Comparable&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Comparable&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;aux&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;lo&lt;/span&gt; &lt;span class="p"&gt;){&lt;/span&gt;   
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;aux&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;   
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="n"&gt;mid&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;less&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;aux&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="n"&gt;aux&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;aux&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;   
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;aux&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;   
&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;aux&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;   
&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;aux&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;note: we use &lt;code&gt;if(less(aux[j],aux[i]))&lt;/code&gt;instead of&lt;code&gt;if(less(aux[j],aux[i]))&lt;/code&gt;, because less(a,b) == true iff a&amp;lt;b (strict), and we want to make mergesort &lt;strong&gt;stable&lt;/strong&gt;. See section (5) below.    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Assertion&lt;/strong&gt; &lt;br /&gt;
We can also add &lt;em&gt;assertions&lt;/em&gt;: &lt;code&gt;assert isSorted(a, lo, mid); assert isSorted(a,mid+1, hi);&lt;/code&gt;    &lt;br /&gt;
Enable/disable assertion at runtime:  &lt;br /&gt;
&lt;code&gt;java -ea MyProgram&lt;/code&gt; //enable assertion &lt;br /&gt;
&lt;code&gt;java -da MyProgram&lt;/code&gt; //disable assertion: &lt;strong&gt;default&lt;/strong&gt; &lt;br /&gt;
Best practice:  &lt;br /&gt;
use assertions to check interval invariants; &lt;br /&gt;
do NOT use assert for external argument checking !    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Mergesort   &lt;/strong&gt; &lt;br /&gt;
为了mergesort需要写两个辅助函数: merge和sort(recursive):   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;MergeSort&lt;/span&gt; &lt;span class="n"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;AbstractSort&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;   
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Comparable&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   
        &lt;span class="n"&gt;Comparable&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;aux&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Comparable&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;   
        &lt;span class="n"&gt;sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;aux&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
    &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Comparable&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Comparable&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;aux&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    
        &lt;span class="n"&gt;sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;aux&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
        &lt;span class="n"&gt;sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;aux&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
        &lt;span class="n"&gt;merge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;aux&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;merge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Comparable&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Comparable&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;aux&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;lo&lt;/span&gt; &lt;span class="p"&gt;){&lt;/span&gt;   
    &lt;span class="c1"&gt;// as before...   &lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;有几点注意的:    &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;注意递归终止条件是&lt;code&gt;hi&amp;lt;=lo&lt;/code&gt;, 不是&lt;code&gt;==&lt;/code&gt;.    &lt;/li&gt;
&lt;li&gt;实现的代码不难, 但是定义好辅助函数的参数并不简单... 比如在merge里使用了mid作为参数.    &lt;/li&gt;
&lt;li&gt;aux的数组直接写在了函数参数里面, 好处是可以防止反复声明数组带来的开销.   &lt;/li&gt;
&lt;li&gt;发现他们写的时候mid都是写成: &lt;code&gt;mid = lo+(hi-lo)/2&lt;/code&gt;, &lt;a href="http://stackoverflow.com/questions/25571359/why-we-write-lohi-lo-2-in-binary-search"&gt;查了一下&lt;/a&gt;发现这样的原因是为了防止hi+lo整数溢出...嗯有道理.    &lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Analysis&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;proposition (time)&lt;/strong&gt; &lt;br /&gt;
Mergesort takes at most NlgN compares and 6NlgN array access.  &lt;br /&gt;
&lt;em&gt;Proof.&lt;/em&gt; &lt;br /&gt;
def: C(N)=#compares for N elements, A(N)=#array access for N elements, the recurrence eq:  &lt;br /&gt;
C(N) &amp;lt;= 2&lt;em&gt;C(N/2) + N; C(1) = 0  (最多N次比较: 每个a[]的数都由比较得到)    &lt;br /&gt;
A(N) &amp;lt;= 2&lt;/em&gt;A(N/2) + 6N; A(1) = 0 (~~这里不太理解为什么是6N, 怎么数都是4N或者5N啊?......~~2N复制到aux, 2N复制回去, 2N比较)    &lt;br /&gt;
&lt;img alt="" src="algoI_week3_1/pasted_image001.png" /&gt;    &lt;br /&gt;
(上图蓝色的一列是extra cost)      &lt;br /&gt;
或者用递推公式, 发现D(N)/N的递推关系:     &lt;br /&gt;
&lt;img alt="" src="algoI_week3_1/pasted_image002.png" /&gt;        &lt;br /&gt;
或者用数学归纳法:    &lt;br /&gt;
&lt;img alt="" src="algoI_week3_1/pasted_image003.png" /&gt;      &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposition(memory)&lt;/strong&gt;    &lt;br /&gt;
Mergesort takes N extra memory. &lt;br /&gt;
⇒ mergesort is NOT &lt;em&gt;in-place&lt;/em&gt; sorting method.    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;def&lt;/strong&gt;. &lt;em&gt;"in-place"&lt;/em&gt; &lt;br /&gt;
A sorting algo is in-place if it uses &amp;lt;C*lgN extra memory.  &lt;br /&gt;
ex. insertion sort, shellsort, selection sort...   &lt;/p&gt;
&lt;h2&gt;Practical improvements&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;use insertion sort for small arrays:     &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;cutoff to insertion sort for &amp;lt;7 items.    &lt;br /&gt;
&lt;img alt="" src="algoI_week3_1/pasted_image004.png" /&gt;    &lt;br /&gt;
⇒ lead to 20% improvement!     &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;stop if alread sorted: *a[mid]&amp;lt;a[mid+1]!   *   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week3_1/pasted_image005.png" /&gt;      &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;switch the role of &lt;code&gt;a[]&lt;/code&gt; and &lt;code&gt;aux[]&lt;/code&gt;   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week3_1/pasted_image006.png" /&gt;       &lt;br /&gt;
&lt;img alt="" src="algoI_week3_1/pasted_image007.png" /&gt;      &lt;/p&gt;
&lt;h1&gt;2. Bottom-up Mergesort&lt;/h1&gt;
&lt;p&gt;bottom-up version of mergesort &lt;em&gt;without recursion&lt;/em&gt;.  &lt;br /&gt;
Idea:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pass and merge subarrays of size 1 in pairs      &lt;/li&gt;
&lt;li&gt;repeat for subarrays of size 2,4,8,....      &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week3_1/pasted_image008.png" /&gt;      &lt;/p&gt;
&lt;h2&gt;implementation&lt;/h2&gt;
&lt;p&gt;看着上面那个图好写一点... 就是每次用更大的size来两两merge一遍数组   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public static void sort&lt;span class="p"&gt;(&lt;/span&gt;Comparable&lt;span class="p"&gt;[]&lt;/span&gt; a&lt;span class="p"&gt;){&lt;/span&gt;   
    Comparable&lt;span class="p"&gt;[]&lt;/span&gt; aux &lt;span class="o"&gt;=&lt;/span&gt; new Comparable&lt;span class="p"&gt;[&lt;/span&gt;a.length&lt;span class="p"&gt;];&lt;/span&gt;   
    &lt;span class="kr"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;int sz&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;sz&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;a.length&lt;span class="p"&gt;;&lt;/span&gt;sz&lt;span class="o"&gt;*=&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   
        &lt;span class="kr"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;int i&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;i&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;a.length&lt;span class="o"&gt;-&lt;/span&gt;sz&lt;span class="p"&gt;;&lt;/span&gt;i&lt;span class="o"&gt;+=&lt;/span&gt;sz&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   
            merge&lt;span class="p"&gt;(&lt;/span&gt; a&lt;span class="p"&gt;,&lt;/span&gt;aux&lt;span class="p"&gt;,&lt;/span&gt;i&lt;span class="p"&gt;,&lt;/span&gt;i&lt;span class="o"&gt;+&lt;/span&gt;sz&lt;span class="m"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;Math.min&lt;span class="p"&gt;(&lt;/span&gt;i&lt;span class="o"&gt;+&lt;/span&gt;sz&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="m"&gt;2-1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="o"&gt;//&amp;lt;-&lt;/span&gt;注意mid和hi的计算方法   
    &lt;span class="p"&gt;}&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;3. Sorting Complexity&lt;/h1&gt;
&lt;p&gt;some items:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;computational model: allowed operations, (ex. &lt;em&gt;decision tree for compare based sorting&lt;/em&gt;).     &lt;/li&gt;
&lt;li&gt;cost model: operation counts.    &lt;/li&gt;
&lt;li&gt;upper bound: cost guarantee (ex. NlgN for mergesort). .    &lt;/li&gt;
&lt;li&gt;lower bound: limit on cost guarantee for all algorithms (no algorithm can do better).    &lt;/li&gt;
&lt;li&gt;Optimal algorithm: algo with best cost guarantee. (upper bound=lower bound)   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;证明lower bound 的方法很有意思:    &lt;/p&gt;
&lt;h2&gt;lower bound for sorting&lt;/h2&gt;
&lt;p&gt;(binary) decision tree for the case of 3 distinct items:      &lt;br /&gt;
&lt;img alt="" src="algoI_week3_1/pasted_image009.png" /&gt;         &lt;/p&gt;
&lt;p&gt;each possible ordering is a leaf of the decision tree → there are N! possible orderings → tree height should be lg(N!) = NlgN (cf. &lt;a href="https://en.wikipedia.org/wiki/Stirling%27s_approximation"&gt;https://en.wikipedia.org/wiki/Stirling%27s_approximation&lt;/a&gt;)    &lt;br /&gt;
&lt;strong&gt;proposition.  &lt;/strong&gt; &lt;br /&gt;
Any compare-based sorting algorithm must have at least lg(N!)~NlgN compares in the worst case. (for N distinct keys)        &lt;br /&gt;
&lt;em&gt;proof.&lt;/em&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;binary tree of height h has at most 2^h leaves     &lt;/li&gt;
&lt;li&gt;N! possible orderings → at least N! leaves     &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week3_1/pasted_image010.png" /&gt;     &lt;br /&gt;
 So, lower bound for sorting = ~NlgN ⇒ &lt;em&gt;mergesort &lt;strong&gt;&lt;em&gt;is&lt;/em&gt;&lt;/strong&gt; an asymptotical optimal algorithm&lt;/em&gt;. (In terms of time complexity, the shortcoming of mergesort is always the extra space usage)   &lt;br /&gt;
&lt;img alt="" src="algoI_week3_1/pasted_image011.png" /&gt;       &lt;br /&gt;
 但是并不是说NlgN是&lt;em&gt;所有&lt;/em&gt;排序问题的下界:   &lt;br /&gt;
&lt;img alt="" src="algoI_week3_1/pasted_image012.png" /&gt;      &lt;/p&gt;
&lt;h1&gt;4. Comparators&lt;/h1&gt;
&lt;p&gt;Java mechenism for comparing same data on different ways.    &lt;/p&gt;
&lt;h2&gt;Comparable interface&lt;/h2&gt;
&lt;p&gt;→Sorting using &lt;em&gt;natural order&lt;/em&gt; for a data type. &lt;br /&gt;
    public class Data implements Comparable&lt;Date&gt;{ &lt;br /&gt;
    public int compareTo(Date that){ &lt;br /&gt;
    //...} &lt;br /&gt;
    }   &lt;/p&gt;
&lt;h2&gt;Comparator interface&lt;/h2&gt;
&lt;p&gt;→Sorting using  an &lt;em&gt;alternative order&lt;/em&gt;. (total order property is required...)   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;interface&lt;/span&gt; &lt;span class="nx"&gt;Comparator&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;Key&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;   
    &lt;span class="nx"&gt;int&lt;/span&gt; &lt;span class="nb"&gt;compare&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;Key&lt;/span&gt; &lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;Key&lt;/span&gt; &lt;span class="nx"&gt;w&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Comparator can be passed as arguments in java system sort:   &lt;br /&gt;
&lt;img alt="" src="algoI_week3_1/pasted_image013.png" /&gt;      &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Using Comparators in our sorting algos   &lt;/strong&gt; &lt;br /&gt;
Use another signature:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;change Comparable to Object   &lt;/li&gt;
&lt;li&gt;
&lt;p&gt;add Comparator in arguments   &lt;/p&gt;
&lt;p&gt;public static void sort(Object[] a, Comparator comparator); &lt;br /&gt;
public static boolean less(Comparator c, Object v, Object w);    &lt;/p&gt;
&lt;p&gt;public static void exch(Object[] a, int i, int j);   &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Implementing a comparator    &lt;/strong&gt; &lt;br /&gt;
Add static comparator to a class:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In the declaration of a class, define an inner class that implements the Comparator interface,    &lt;/li&gt;
&lt;li&gt;Then declare an instance of this inner class as a static final variable...   &lt;/li&gt;
&lt;li&gt;note: the inner class should be &lt;strong&gt;static&lt;/strong&gt; also.      &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week3_1/pasted_image014.png" /&gt;    &lt;br /&gt;
以上的方法目的是为某个类提供预先定义好的comparator(比如&lt;code&gt;String.CASE_INSENSITIVE_ORDER&lt;/code&gt;), 另外也可以直接再声明一个类作为comparator, 然后实例化这个类传进去, 就像之前做过的那样.    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Application: Graham scan algo for convex hull  &lt;/strong&gt; &lt;br /&gt;
&lt;img alt="" src="algoI_week3_1/pasted_image015.png" /&gt;    &lt;br /&gt;
We can get the result of compare by calling &lt;code&gt;ccw(a,b,c)&lt;/code&gt; : &lt;br /&gt;
*ccw(p,q1,q2)=true ⇔ q2&amp;gt;q1 in terms of polar angle wrt p. (别忘了p是y坐标最小的点, 否则还要讨论角坐标为负数的情况, 见下图).    * &lt;br /&gt;
&lt;img alt="" src="algoI_week3_1/pasted_image016.png" /&gt;         &lt;/p&gt;
&lt;h1&gt;5. Stability&lt;/h1&gt;
&lt;p&gt;Typical application: first sort by student name then by section.    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;def. :stable"&lt;/strong&gt; &lt;br /&gt;
&lt;em&gt;A stable sort preserves the relative order for items with equal keys.&lt;/em&gt;    &lt;/p&gt;
&lt;p&gt;&lt;em&gt;Insertion sort and mergesort are stable, whereas selection sort and shell sort are not.&lt;/em&gt; (And always need to carefully check code: "less than" vs. "less than or equal to").   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;insertion sort:&lt;/strong&gt;    &lt;br /&gt;
stable &lt;br /&gt;
proof: we never move equal items pass each other: &lt;code&gt;if(less(a[j], a[j-1])) exch(...)&lt;/code&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;selection sort:  &lt;/strong&gt; &lt;br /&gt;
not stable   &lt;br /&gt;
counter example:  &lt;br /&gt;
when exchanging A1 and B1, we move B1 behind B2    &lt;br /&gt;
&lt;img alt="" src="algoI_week3_1/pasted_image017.png" /&gt;        &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;shell sort:  &lt;/strong&gt; &lt;br /&gt;
counter example: long-dist exchanges   &lt;br /&gt;
&lt;img alt="" src="algoI_week3_1/pasted_image018.png" /&gt;      &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;merge sort:   &lt;/strong&gt; &lt;br /&gt;
stable &lt;br /&gt;
proof: suffices to verify that merge operation is stable, if keys are equal, always take element from left subarray.    &lt;/p&gt;</summary><category term="algorithm"></category></entry><entry><title>[Algorithms I] Week 2-2 Elementary Sorts</title><link href="http://x-wei.github.io/algoI_week2_2.html" rel="alternate"></link><updated>2015-08-18T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/algoI_week2_2.html</id><summary type="html">&lt;h1&gt;1. Introduction&lt;/h1&gt;
&lt;p&gt;rearanging array of size N into ascending order &lt;br /&gt;
test client code: &lt;code&gt;Insertion.sort(a);&lt;/code&gt;   &lt;/p&gt;
&lt;p&gt;sort &lt;em&gt;any&lt;/em&gt; datatype &lt;/p&gt;
&lt;h3&gt;callback&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;callback = reference to executable code&lt;/em&gt; &lt;br /&gt;
i.e. passing functions as argument to sort() method&lt;br /&gt;
sort() function calls object's &lt;code&gt;compareTo()&lt;/code&gt; method  &lt;br /&gt;
&lt;img alt="" src="algoI_week2_2/pasted_image.png" /&gt; &lt;br /&gt;
→ implement the &lt;code&gt;Comparable&lt;/code&gt; interface:    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;    &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;XX&lt;/span&gt; &lt;span class="nx"&gt;implements&lt;/span&gt; &lt;span class="nx"&gt;Comparable&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;XX&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;...&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;the interface: &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;    &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;interface&lt;/span&gt; &lt;span class="nx"&gt;Comparable&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;Item&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;int&lt;/span&gt; &lt;span class="nx"&gt;compareTo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;Item&lt;/span&gt; &lt;span class="nx"&gt;that&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;compareTo():&lt;br /&gt;
return -1 (if this&amp;lt;that)/+1/0; 
needs a &lt;em&gt;total order.&lt;/em&gt; 
→ in the sort() implementation:&lt;br /&gt;
has not dependencies on type of data.  &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Comparable&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;compareTo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)...&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;helper functions&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;less&lt;/p&gt;
&lt;p&gt;private static boolean less(Comparable v, Comparable u){
returnv.compareTo(u)&amp;lt;0;
}&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;exch&lt;/p&gt;
&lt;p&gt;private void exch(Comparable[] a, int i, int j) {
        Comparable swap = a[i];
        a[i] = a[j];
        a[j] = swap;
    }&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;isSorted&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;test if sorted
if algo passes the test using only less ant swap, then it's correct. &lt;/p&gt;
&lt;h1&gt;2. Selection Sort&lt;/h1&gt;
&lt;p&gt;Idea: each time&lt;em&gt;: find the minimum from the remaining items.&lt;/em&gt; 
&lt;strong&gt;a[min] is the smallest element to right of a[i] ⇒ swap a[i] and a[min]&lt;/strong&gt; (elements to left of i are sorted) &lt;br /&gt;
&lt;img alt="" src="algoI_week2_2/pasted_image002.png" /&gt;    &lt;/p&gt;
&lt;h2&gt;invariants&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;entries to the left of i are in sorted order, and are fixed (&lt;em&gt;in final position&lt;/em&gt;) ever since&lt;/li&gt;
&lt;li&gt;no entry to the right of i is smaller than any entry to the left of i&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;implementation&lt;/h2&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;SelectionSort&lt;/span&gt; &lt;span class="n"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;AbstractSorting&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Comparable&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;min&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;less&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;min&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt; 
                &lt;span class="n"&gt;min&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;exch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;min&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;analysis&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;proposition:&lt;/strong&gt;
selection sort uses &lt;em&gt;N-1 + N-2 + ... + 1 = ~N^2/2&lt;/em&gt; compares, and &lt;em&gt;N&lt;/em&gt; exchanges. 
→ quadratic time&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week2_2/pasted_image003.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;insensitive&lt;/strong&gt; to input: quadratic time &lt;em&gt;even if input is already sorted.&lt;/em&gt; &lt;/li&gt;
&lt;li&gt;data movement is &lt;em&gt;minimum&lt;/em&gt;: linear time of exchanges (every exchange puts an item to its final position)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;3. Insertion sort&lt;/h1&gt;
&lt;p&gt;quite different performance characteritics than selection sort. &lt;/p&gt;
&lt;p&gt;Idea: &lt;strong&gt;In iteration i: move all entries larger than a[i] to its left.&lt;/strong&gt;  &lt;br /&gt;
&lt;img alt="" src="algoI_week2_2/pasted_image004.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;invariants&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;entries to the left of i are in ascending order (but &lt;em&gt;not&lt;/em&gt; in final position)&lt;/li&gt;
&lt;li&gt;entries to the right of i are not yet been seen   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week2_2/pasted_image005.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;implementation&lt;/h2&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;publc&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;InsertionSorting&lt;/span&gt; &lt;span class="n"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;AbstractSorting&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Comparable&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;less&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;
                    &lt;span class="n"&gt;exch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;analysis&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;proposition &lt;/strong&gt;(average case): &lt;br /&gt;
(the performance &lt;em&gt;on average&lt;/em&gt; — &lt;em&gt;for randomly sorted array&lt;/em&gt; ) &lt;br /&gt;
&lt;img alt="" src="algoI_week2_2/pasted_image007.png" /&gt; &lt;br /&gt;
&lt;em&gt;proof:&lt;/em&gt;
&lt;em&gt;expect each entry to move halfway back&lt;/em&gt; &lt;br /&gt;
&lt;img alt="" src="algoI_week2_2/pasted_image008.png" /&gt;   &lt;/p&gt;
&lt;h3&gt;best case and worst case&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;best case&lt;/strong&gt;
if array already sorted min ascending order: 
&lt;em&gt;N-1 compares, 0 exchanges.&lt;/em&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;worst case&lt;/strong&gt;
if array sorted in descending order: 
every element goes all the way back → 1/2&lt;em&gt;N^2 compares,  1/2&lt;/em&gt;N^2 exchanges&lt;/p&gt;
&lt;h3&gt;partially  sorted arrays&lt;/h3&gt;
&lt;p&gt;def.&lt;strong&gt;" inversion"&lt;/strong&gt;
an inversion is a pair of entries that are out of order. &lt;/p&gt;
&lt;p&gt;def. &lt;strong&gt;"partially sorted"&lt;/strong&gt;&lt;br /&gt;
An array is called partially sorted if the &lt;em&gt;number of inversions is &amp;lt;= c&lt;/em&gt;N. *&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;proposition. &lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;Insertion sort runs in linear time for partially sorted array.&lt;/strong&gt; 
&lt;em&gt;proof.&lt;/em&gt; 
&lt;em&gt;number of exchanges = number of inversions. &lt;/em&gt;
&lt;em&gt;number of compares = number of exchanges + N-1&lt;/em&gt;&lt;/p&gt;
&lt;h1&gt;4. Shell Sort&lt;/h1&gt;
&lt;p&gt;First non-trival sorting methode: an improvement of insertion sort. &lt;/p&gt;
&lt;p&gt;def. &lt;strong&gt;"h-sorted array"&lt;/strong&gt;&lt;br /&gt;
an array is h-sorted if every h-interleaved subarray is sorted. (h=1: just a sorted array)  &lt;br /&gt;
&lt;img alt="" src="algoI_week2_2/pasted_image009.png" /&gt;     &lt;/p&gt;
&lt;p&gt;Idea: move entries &amp;gt;1 position at a time by &lt;em&gt;h-sorting&lt;/em&gt; the array, then decrease h.   &lt;/p&gt;
&lt;p&gt;use decreasing sequences of value h:  &lt;br /&gt;
&lt;img alt="" src="algoI_week2_2/pasted_image010.png" /&gt;     &lt;/p&gt;
&lt;h2&gt;implementation&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;How to h -sort  &lt;/strong&gt;&lt;br /&gt;
simply insertion sort with &lt;em&gt;stride length=h&lt;/em&gt;.&lt;br /&gt;
why insertion sort: &lt;br /&gt;
for big h: small subarray &lt;br /&gt;
for small h: nearly in order   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;proposition&lt;/strong&gt;&lt;br /&gt;
A g-sorted array &lt;em&gt;remains g-sorted&lt;/em&gt; after h-sorting it.  &lt;br /&gt;
&lt;img alt="" src="algoI_week2_2/pasted_image011.png" /&gt;  &lt;br /&gt;
(subtle to prove...)  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;which sequence of h to use&lt;/strong&gt;
&lt;code&gt;3x+1&lt;/code&gt; sequence proposed by Knuth. &lt;em&gt;1,4,13,40....&lt;/em&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;ShellSort&lt;/span&gt; &lt;span class="n"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;AbstractSort&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Comparable&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//find the beginning h (N&amp;gt;h&amp;gt;N/3)&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="c1"&gt;//performs h-sort&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;less&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
                        &lt;span class="n"&gt;exch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;//...&lt;/span&gt;
    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;boolean&lt;/span&gt; &lt;span class="n"&gt;isHsorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Comparable&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;less&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;每次hsort, 外围的循环是&lt;code&gt;for(int i= h;i&amp;lt;N;i+=h)&lt;/code&gt;, 需要理解一下: i移动一次以后, 进行的是另一个subarray 的插入排序, 当移动到N-1的时候所有subarray的插入排序才结束. (也就是说不是先完成一个subarray的插入排序再完成另一个, 这些是插入排序是同步进行的)&lt;/p&gt;
&lt;h2&gt;analysis&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;proposition (for worst case   )&lt;/strong&gt;&lt;br /&gt;
&lt;img alt="" src="algoI_week2_2/pasted_image012.png" /&gt;   &lt;br /&gt;
→ better than quadratic time !     &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;property  (found in practice)&lt;/strong&gt;&lt;/p&gt;
&lt;h1&gt;of compares &amp;lt; Cte * N * (# of &lt;em&gt;h&lt;/em&gt; used )&lt;/h1&gt;
&lt;p&gt;→ #compares &amp;lt; NlgN * Cte &lt;br /&gt;
&lt;img alt="" src="algoI_week2_2/pasted_image013.png" /&gt; &lt;br /&gt;
*accurate model has not been discovered  *&lt;/p&gt;
&lt;p&gt;(所以shellsort在实际使用中几乎和快速排序一样快! — 尽管没有数学证明来保证)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;why we are interested in shell sort&lt;/strong&gt;
useful in practice: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;fast for medium sized arrays (beat even the classical sophistiated algorithms)  &lt;/li&gt;
&lt;li&gt;tiny code volumn (used in embeded systems)  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;lead to interesting questions for 50 years: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;asymptotic growth rate ?&lt;/li&gt;
&lt;li&gt;best sequence of h ?&lt;/li&gt;
&lt;li&gt;average case performance ?&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;5. shuffling&lt;/h1&gt;
&lt;h2&gt;shuffle array using sort&lt;/h2&gt;
&lt;p&gt;one way to shuffle an array: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;for each array entry, generate a random real number&lt;/li&gt;
&lt;li&gt;sort the array of real numbers&lt;/li&gt;
&lt;li&gt;⇒ the original array is shuffled !&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;proposition  &lt;/strong&gt;&lt;br /&gt;
this shuffle sort produces a uniformly random permutation of input array &lt;br /&gt;
&lt;em&gt;drawback:  cost for sorting...&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Goal: get uniformly random permutation in &lt;em&gt;linear time&lt;/em&gt;.   &lt;/p&gt;
&lt;h2&gt;Knuth shuffle&lt;/h2&gt;
&lt;p&gt;algo:  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;for i = [0,N):&lt;br /&gt;
    - r = rand( [0~i&lt;strong&gt;]&lt;/strong&gt; ) or rand( &lt;strong&gt;[&lt;/strong&gt;i, N-1] ) &lt;br /&gt;
    - swap a[r] and a[i]   &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week2_2/pasted_image014.png" /&gt;&lt;/p&gt;
&lt;p&gt;implementation: &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;shuffle&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;StdRandom&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;uniform&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;exch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;proposition&lt;/strong&gt;&lt;br /&gt;
Knuth algo produces an uniformly random permutation of input array. &lt;/p&gt;
&lt;p&gt;&lt;em&gt;proof.&lt;/em&gt;&lt;br /&gt;
Sufficient to prove that, for card i and position j, the proba(card i comes to position j) = 1/N. &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;if i&amp;lt;=j, P = 1/j * j/(j+1) * (j+1)/(j+2) * ... * (N-1)/N&lt;/li&gt;
&lt;li&gt;if j&amp;lt;i, P = 1/i * i/(i+1) * (i+1)/(i+2) * ... * (N-1)/N&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;CQFD.&lt;/p&gt;
&lt;h2&gt;example: online poker&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.cigital.com/papers/download/developer_gambling.php"&gt;https://www.cigital.com/papers/download/developer_gambling.php&lt;/a&gt;  ←那个扑克网站已经被黑出翔了...  &lt;br /&gt;
&lt;img alt="" src="algoI_week2_2/pasted_image015.png" /&gt;  &lt;br /&gt;
bugs: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;r never get 52 (52th card never moved)&lt;/li&gt;
&lt;li&gt;r = rand(N) instead of rand(0~i), → shuffle not uniform&lt;/li&gt;
&lt;li&gt;random() uses 32bit seed: only 2^32 possible shuffles, &lt;em&gt;2^32&amp;lt;52!&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;seed = millisec from midnight, ~86*10^6 suffles&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;6. Convex Hull&lt;/h1&gt;
&lt;p&gt;application of sorting for the field of computational geometry.  &lt;/p&gt;
&lt;h2&gt;convex hull&lt;/h2&gt;
&lt;p&gt;smallest polygoneenclosing all N points. &lt;br /&gt;
&lt;img alt="" src="algoI_week2_2/pasted_image017.png" /&gt;      &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;input: N points&lt;/li&gt;
&lt;li&gt;output: sequence of &lt;em&gt;vertices&lt;/em&gt; in counterclockwise (&lt;em&gt;ccw&lt;/em&gt;) order. &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;application: robot motion planning; farest pair.   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;geometric properties&lt;/strong&gt;:   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;can traverse convex hull by making only ccw turns&lt;/li&gt;
&lt;li&gt;let p be the point with lowest y-coord, wrt p, vertices appear in increasing order of polar angle.   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week2_2/pasted_image018.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;Algo&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Graham scan algorithm:&lt;/strong&gt;&lt;br /&gt;
    * choose p with smallest y coord &lt;br /&gt;
    * &lt;em&gt;sort points by polar angle&lt;/em&gt; with p &lt;br /&gt;
    * consider points in order (stack is used), &lt;em&gt;discard unless creates a ccw turn&lt;/em&gt;.   &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week2_2/pasted_image019.png" /&gt;   &lt;img alt="" src="algoI_week2_2/pasted_image020.png" /&gt;    &lt;img alt="" src="algoI_week2_2/pasted_image021.png" /&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CCW&lt;/strong&gt; &lt;br /&gt;
given three points a b c, returns if a→b→c is a CCW turn.  &lt;br /&gt;
&lt;img alt="" src="algoI_week2_2/pasted_image023.png" /&gt;    &lt;br /&gt;
(assumption: no 3 points on a line)&lt;br /&gt;
 ⇒ calculate &lt;em&gt;cross product of ab and bc ⇒ determinants!&lt;/em&gt; &lt;br /&gt;
&lt;img alt="" src="algoI_week2_2/pasted_image024.png" /&gt;   &lt;br /&gt;
area&amp;gt;0 ⇔ CCW   &lt;/p&gt;
&lt;h2&gt;implementation&lt;/h2&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Point2D&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;boolean&lt;/span&gt; &lt;span class="nf"&gt;ccw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Point2D&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;Point2D&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;Point2D&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;area2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;area2&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;convex hull:   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;static&lt;/span&gt; &lt;span class="nb"&gt;Stack&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;Point2D&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;GrahamScan&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;Point2D&lt;/span&gt;&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; p){
    //* assumes that points are sorted by polar angle in p&lt;span class="cp"&gt;[]&lt;/span&gt;
    Stack&lt;span class="nt"&gt;&amp;lt;Point2D&amp;gt;&lt;/span&gt; hull = new Stack&lt;span class="nt"&gt;&amp;lt;Point2D&amp;gt;&lt;/span&gt;();
    hull.push(p&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;);
    hull.push(p&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;);
    for(int i=2;i&lt;span class="nt"&gt;&amp;lt;p&lt;/span&gt;&lt;span class="err"&gt;.&lt;/span&gt;&lt;span class="na"&gt;length&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="na"&gt;i&lt;/span&gt;&lt;span class="err"&gt;++){&lt;/span&gt;
        &lt;span class="na"&gt;Point2D&lt;/span&gt; &lt;span class="na"&gt;b =&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="s"&gt;hull.pop(),&lt;/span&gt; &lt;span class="na"&gt;a =&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="s"&gt;hull.peek(),&lt;/span&gt; &lt;span class="na"&gt;c =&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="s"&gt;p&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="s"&gt;;&lt;/span&gt;
        &lt;span class="na"&gt;while&lt;/span&gt;&lt;span class="err"&gt;(!&lt;/span&gt;&lt;span class="na"&gt;Point2D&lt;/span&gt;&lt;span class="err"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ccw&lt;/span&gt;&lt;span class="err"&gt;(&lt;/span&gt;&lt;span class="na"&gt;a&lt;/span&gt;&lt;span class="err"&gt;,&lt;/span&gt;&lt;span class="na"&gt;b&lt;/span&gt;&lt;span class="err"&gt;,&lt;/span&gt;&lt;span class="na"&gt;c&lt;/span&gt;&lt;span class="err"&gt;)){&lt;/span&gt;
            &lt;span class="na"&gt;b =&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="s"&gt;hull.pop();&lt;/span&gt;
            &lt;span class="na"&gt;a =&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="s"&gt;hull.peek();&lt;/span&gt;
        &lt;span class="err"&gt;}&lt;/span&gt;
        &lt;span class="err"&gt;//&lt;/span&gt;&lt;span class="na"&gt;now&lt;/span&gt; &lt;span class="na"&gt;a&lt;/span&gt;&lt;span class="err"&gt;,&lt;/span&gt;&lt;span class="na"&gt;b&lt;/span&gt;&lt;span class="err"&gt;,&lt;/span&gt;&lt;span class="na"&gt;c&lt;/span&gt; &lt;span class="na"&gt;makes&lt;/span&gt; &lt;span class="na"&gt;a&lt;/span&gt; &lt;span class="na"&gt;ccw&lt;/span&gt; &lt;span class="na"&gt;turn:&lt;/span&gt;
        &lt;span class="na"&gt;hull&lt;/span&gt;&lt;span class="err"&gt;.&lt;/span&gt;&lt;span class="na"&gt;push&lt;/span&gt;&lt;span class="err"&gt;(&lt;/span&gt;&lt;span class="na"&gt;b&lt;/span&gt;&lt;span class="err"&gt;);&lt;/span&gt;
        &lt;span class="na"&gt;hull&lt;/span&gt;&lt;span class="err"&gt;.&lt;/span&gt;&lt;span class="na"&gt;push&lt;/span&gt;&lt;span class="err"&gt;(&lt;/span&gt;&lt;span class="na"&gt;c&lt;/span&gt;&lt;span class="err"&gt;);&lt;/span&gt;
    &lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;running time: &lt;em&gt;NlgN for sorting and linear for the rest.&lt;/em&gt; &lt;/p&gt;</summary><category term="algorithm"></category></entry><entry><title>[Algorithms I] Week 2-1 Stacks and Queues</title><link href="http://x-wei.github.io/algoI_week2_1.html" rel="alternate"></link><updated>2015-07-09T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/algoI_week2_1.html</id><summary type="html">&lt;p&gt;fundamental data types: stacks and queues
operations: 
&lt;strong&gt;insert, remove, test empy, iterate,&lt;/strong&gt;...  &lt;br /&gt;
&lt;img alt="" src="algoI_week2_1/pasted_image.png" /&gt;  &lt;/p&gt;
&lt;p&gt;module programming: seperate interface and implementation&lt;/p&gt;
&lt;h1&gt;1. Stacks&lt;/h1&gt;
&lt;p&gt;ex. a stack of strings&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;API: &lt;/p&gt;
&lt;p&gt;public interface StackoOfStrings{
    void push(String item);
    String pop();
    boolean isEmpty();
    //int size();
}&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;implementation 1: using a linkedlist&lt;/h3&gt;
&lt;p&gt;insert/remove from the top of the linkedlist&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;inner class&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;ListNode&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;ListNode&lt;/span&gt; &lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;implementation  &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;LinkedStackOfStrings&lt;/span&gt; &lt;span class="n"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;StackoOfStrings&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ListNode&lt;/span&gt; &lt;span class="n"&gt;nxt&lt;/span&gt;&lt;span class="p"&gt;){...}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;LinkedStackOfStrings&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
        &lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="nf"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
        &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;firstItem&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;firstItem&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;boolean&lt;/span&gt; &lt;span class="nf"&gt;isEmpty&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;complexity: const time for every operation&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;array implementation&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;use array (of length N) to store items → defect: stack has limited capacity&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;keep a pointer *top: &lt;strong&gt;*pointing to the next empty space to push &lt;/strong&gt;(top 的定义很重要)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;problems of the array implementation: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;underflow: pop from an empty stack  &lt;/li&gt;
&lt;li&gt;overflow: size larger than capacity ⇒ resizing  &lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;loitering&lt;/strong&gt;: holding a ref to an obj which is no longer needed:
ex. &lt;code&gt;return s[top--]&lt;/code&gt;
java system will not know that s[top] is no longer needed ⇒ have to clear it explicitely
⇒   &lt;/p&gt;
&lt;p&gt;String item = s[top--]; 
s[top]=null; 
return item&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;implementation (containg resizing array operations)  &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;ArrayStackOfStrings&lt;/span&gt; &lt;span class="n"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;StackOfStrings&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;ArrayStackOfStrings&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;&lt;span class="c1"&gt;// to be tuned&lt;/span&gt;
            &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="c1"&gt;//initial capacity=1&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;boolean&lt;/span&gt; &lt;span class="nf"&gt;isEmpty&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;vois&lt;/span&gt; &lt;span class="nf"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="c1"&gt;//helper functoin&lt;/span&gt;
            &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;s2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="n"&gt;s2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
            &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;s2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="c1"&gt;//doubling size &lt;/span&gt;
                &lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lenth&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="nf"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
            &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="c1"&gt;//NOT top--!&lt;/span&gt;
            &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//top&amp;gt;0 is necessary&lt;/span&gt;
                &lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;2. Resizing Arrays&lt;/h1&gt;
&lt;p&gt;resolving the overflow pb: grow and shrink the array
→ need to copy all items when changing array size
⇒ pb: &lt;em&gt;ensure that sizing happens infrequently&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;resizing strategy&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;repeated doubling:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(initial capacity=1) when array is full, double the size&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;amortized&lt;/em&gt; complexity for inserting N:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;N+(2+4+8+...+N) ~3N&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;shrinking array&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;⇒ shrink the array by half when array is &lt;strong&gt;1/4 full&lt;/strong&gt;
not half full → &lt;em&gt;thrashing&lt;/em&gt; will happen if push-pop-push-pop when array is full &lt;br /&gt;
&lt;img alt="" src="algoI_week2_1/pasted_image001.png" /&gt;      &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;[invariant]&lt;/strong&gt;: array always 20%~100% full&lt;/li&gt;
&lt;li&gt;complexity:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;in an amortized sense&lt;/em&gt;, will be constant &lt;br /&gt;
&lt;img alt="" src="algoI_week2_1/pasted_image002.png" /&gt;  &lt;br /&gt;
&lt;strong&gt;proposition&lt;/strong&gt;: from empty stack, M operations of push/pop taked time propotional to M&lt;/p&gt;
&lt;h3&gt;comparison: resizable array vs linkedlist&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;linkedlist implementation: &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;operations takes const time even in worst time
extra time and space for dealing with linkes &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;resizing array implementation:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;operation taked const &lt;em&gt;amortized&lt;/em&gt; time
but in worst case takes linear time (ex. to be evited for critical systems)
less wasted space&lt;/p&gt;
&lt;h2&gt;3. Queues&lt;/h2&gt;
&lt;p&gt;FIFO data structure
API&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;interface&lt;/span&gt; &lt;span class="n"&gt;QueueOfStrings&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;enqueue&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="nf"&gt;dequeue&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;boolean&lt;/span&gt; &lt;span class="nf"&gt;isEmpty&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="c1"&gt;//int size();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;linked list implementation&lt;/h3&gt;
&lt;p&gt;maintain &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt; node pointers: 
pointing to 2 points of queue (&lt;code&gt;first&lt;/code&gt; for dequeue, &lt;code&gt;last&lt;/code&gt; for enqueue ) &lt;br /&gt;
&lt;img alt="" src="algoI_week2_1/pasted_image003.png" /&gt;   &lt;br /&gt;
→ &lt;em&gt;take care of corner cases&lt;/em&gt;: 
- empty queue: first is null (and last is also null) 
- just one item in queue: first and last &lt;em&gt;point to the same node&lt;/em&gt;
(总之first和last的定义很重要)&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;LinkedQueueOfStrings&lt;/span&gt; &lt;span class="n"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;QueueOfStrings&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;{...&lt;/span&gt;  &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;LinkedQueueOfStrings&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
            &lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;enqueue&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="c1"&gt;//same as push&lt;/span&gt;
            &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;isEmpty&lt;/span&gt;&lt;span class="p"&gt;()){&lt;/span&gt;
                &lt;span class="n"&gt;last&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;last&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="nf"&gt;dequeue&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;&lt;span class="c1"&gt;//same as pop in stack&lt;/span&gt;
            &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;firstItem&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;isEmpty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
                &lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;firstItem&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;boolean&lt;/span&gt; &lt;span class="nf"&gt;isEmpty&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;resizing array implementation&lt;/h3&gt;
&lt;p&gt;maintain &lt;code&gt;head&lt;/code&gt; and &lt;code&gt;tail&lt;/code&gt;: 
&lt;code&gt;head&lt;/code&gt; is the queue head, &lt;code&gt;tail&lt;/code&gt; is the &lt;em&gt;next empty position&lt;/em&gt; for the next element to enqueue
→ trick: head and tail should take &lt;em&gt;mod capacity + &lt;/em&gt;resizing array &lt;br /&gt;
&lt;img alt="" src="algoI_week2_1/pasted_image004.png" /&gt; &lt;br /&gt;
不知道写的对不对: &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;ArrayQueueOfStrings&lt;/span&gt; &lt;span class="n"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;QueueOfStrings&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;tail&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;LinkedQueueOfStrings&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
            &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="c1"&gt;//init capacity&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;boolean&lt;/span&gt; &lt;span class="nf"&gt;isEmpty&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;tail&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;newsz&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
            &lt;span class="n"&gt;q2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;newsz&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
            &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="n"&gt;tail&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
                &lt;span class="n"&gt;q2&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
                &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;q2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;tail&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;enqueue&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tail&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;tail&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;tail&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tail&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="nf"&gt;dequeue&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
            &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;firstItem&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
            &lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sz&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tail&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sz&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;sz&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;firstItem&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;4. Generics&lt;/h1&gt;
&lt;p&gt;queues/stacks for other types of data ⇒ &lt;em&gt;generics 泛型&lt;/em&gt;(java 1.5 才引进泛型机制...)
use &lt;em&gt;type paramater&lt;/em&gt;→ avoid casting, and discover type mismatch errors &lt;em&gt;at compile time&lt;/em&gt; &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;    &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;interface&lt;/span&gt; &lt;span class="nb"&gt;Stack&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;Item&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;void&lt;/span&gt; &lt;span class="nb"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;Item&lt;/span&gt; &lt;span class="nb"&gt;item&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;Item&lt;/span&gt; &lt;span class="nb"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;boolean&lt;/span&gt; &lt;span class="nb"&gt;isEmpty&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;a pb with array implementation&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;java不支持创立泛型数组&lt;/strong&gt;
generic array creation is not allowed. 不可以new 一个泛型数组!
&lt;code&gt;s = new Item[capacity];&lt;/code&gt;会报错 &lt;br /&gt;
⇒ use an ugly &lt;em&gt;cast&lt;/em&gt;:
&lt;code&gt;s = (Item[]) new Object[capacity];&lt;/code&gt;
(will get warning: "unchecked cast" → java被黑了... )&lt;/p&gt;
&lt;h3&gt;autoboxing for primitive types&lt;/h3&gt;
&lt;p&gt;each primitive type has a &lt;em&gt;wrapper class&lt;/em&gt;
ex. int ↔ Integer
autoboxing: automatic cast between a primitive type and its wrapper class. &lt;br /&gt;
&lt;img alt="" src="algoI_week2_1/pasted_image005.png" /&gt; &lt;br /&gt;
(syntactic sugar 语法糖 i.e. 对语言功能没有影响只是方便使用)&lt;br /&gt;
btw: &lt;a href="https://zh.wikipedia.org/wiki/%E8%AF%AD%E6%B3%95%E7%B3%96"&gt;https://zh.wikipedia.org/wiki/%E8%AF%AD%E6%B3%95%E7%B3%96&lt;/a&gt; (居然还有语法盐和语法糖精......)&lt;/p&gt;
&lt;h1&gt;5. Iterators&lt;/h1&gt;
&lt;h3&gt;Interface&lt;/h3&gt;
&lt;p&gt;support iteration over stacks and queues, &lt;em&gt;without revealing the internal representation&lt;/em&gt; of stack/queue
⇒ implement the &lt;code&gt;Iterable&lt;/code&gt; interface&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Iterable&lt;/code&gt; interface: can return an *Iterator *&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;interface&lt;/span&gt; &lt;span class="nx"&gt;Iterable&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nb"&gt;Iterator&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;Item&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;iterator&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Iterator interface: hasNext() and next() interface&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;interface&lt;/span&gt; &lt;span class="nb"&gt;Iterator&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;Item&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nb"&gt;boolean&lt;/span&gt; &lt;span class="nx"&gt;hasNext&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="nb"&gt;Item&lt;/span&gt; &lt;span class="nb"&gt;next&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="bp"&gt;void&lt;/span&gt; &lt;span class="nb"&gt;remove&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="c1"&gt;//optional, bad practice to use it&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;to make a data structure Interable → elegant client code   &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week2_1/pasted_image006.png" /&gt; &lt;br /&gt;
&lt;strong&gt;how-to:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;implement &lt;code&gt;Iterable&lt;/code&gt; interface&lt;/li&gt;
&lt;li&gt;write a &lt;em&gt;private inner class&lt;/em&gt; XXIterator that implment the &lt;code&gt;Iterator&lt;/code&gt; interface.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ex. &lt;br /&gt;
&lt;img alt="" src="algoI_week2_1/pasted_image007.png" /&gt;   &lt;/p&gt;
&lt;h3&gt;Bag data structure&lt;/h3&gt;
&lt;p&gt;Supports adding and iterating through without caring about the order.&lt;br /&gt;
API: &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;    &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;class&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;Item&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;Bag&lt;/span&gt; &lt;span class="nx"&gt;implements&lt;/span&gt; &lt;span class="nx"&gt;Iterable&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;Item&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;void&lt;/span&gt; &lt;span class="nb"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;Item&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="nx"&gt;int&lt;/span&gt; &lt;span class="nb"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; 
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;can be implemented by stack or queue(without pop/dequeue)&lt;/p&gt;
&lt;h1&gt;6. Applications&lt;/h1&gt;
&lt;h3&gt;Java collections library&lt;/h3&gt;
&lt;p&gt;List interface: &lt;code&gt;java.util.List&lt;/code&gt; &lt;br /&gt;
&lt;img alt="" src="algoI_week2_1/pasted_image008.png" /&gt;   &lt;br /&gt;
implementations: &lt;code&gt;ArrayList&lt;/code&gt;, &lt;code&gt;LinkedList&lt;/code&gt;. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pb with the java's implementation of stacks and queues:  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Stack&lt;/code&gt; class also implements List interface (&lt;code&gt;get()&lt;/code&gt;, &lt;code&gt;remove()&lt;/code&gt;, &lt;code&gt;contains()&lt;/code&gt; are implemented);&lt;br /&gt;
&lt;code&gt;Queue&lt;/code&gt; is an interface rather than a class...&lt;br /&gt;
⇒ &lt;strong&gt;poorly designed API  &lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;Stacks applications&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;function calls: &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week2_1/pasted_image009.png" /&gt;  &lt;br /&gt;
recursion: can always use an explicit stack to remove recursion&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;arithemic evaluation (Dijkstra)  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;四种类型: 左括号, 右括号, 数字, 算子  &lt;br /&gt;
&lt;img alt="" src="algoI_week2_1/pasted_image010.png" /&gt;&lt;br /&gt;
最后一行应该是value stack.  &lt;br /&gt;
&lt;img alt="" src="algoI_week2_1/pasted_image011.png" /&gt;   &lt;/p&gt;
&lt;p&gt;⇒ 后缀表达式, 逆波兰式......&lt;/p&gt;</summary><category term="algorithm"></category></entry><entry><title>[Algorithms I] Week1-Lab: Percolation</title><link href="http://x-wei.github.io/algoI_week1_lab.html" rel="alternate"></link><updated>2015-07-07T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/algoI_week1_lab.html</id><summary type="html">&lt;h1&gt;model &amp;amp; problem&lt;/h1&gt;
&lt;p&gt;(原文描述太啰嗦了)&lt;br /&gt;
A system using an N-by-N grid of sites. &lt;br /&gt;
→ Each site is either open or blocked. &lt;br /&gt;
→ A &lt;strong&gt;full&lt;/strong&gt; site is an open site that can be connected to an open site in the top row via a chain of neighboring open sites. (这个full的定义有玄机 而且导致后面写程序时有个问题, 看论坛想了半天才想出来, 见后文.)&lt;br /&gt;
→ We say the system &lt;strong&gt;percolates&lt;/strong&gt; if there is a path of connected open sites form the top row to the bottom row.   &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="file:///home/wx/Dropbox/ZIM_NOTES/0._TmpNotes/Algorithms%2C_4th_ed/Week1-Assignment-Percolation/pasted_image.png" /&gt;   &lt;/p&gt;
&lt;p&gt;⇒ pb: if sites are independently set to be open with probability &lt;strong&gt;p&lt;/strong&gt;, what is the probability that the system percolates? &lt;br /&gt;
&lt;img alt="" src="file:///home/wx/Dropbox/ZIM_NOTES/0._TmpNotes/Algorithms%2C_4th_ed/Week1-Assignment-Percolation/pasted_image001.png" /&gt; &lt;br /&gt;
→ When N is sufficiently large, there is a threshold value **p&lt;strong&gt;&lt;em&gt; such that when p &amp;lt; p&lt;/em&gt; a random N-by-N grid almost never percolates, and when p &amp;gt; p&lt;em&gt;, a random N-by-N grid almost always percolates. &lt;br /&gt;
→ No mathematical solution for determining the percolation threshold p&lt;/em&gt; has yet been derived. &lt;br /&gt;
⇒ Your task is to *write a computer program to estimate p&lt;/strong&gt;.   &lt;/p&gt;
&lt;h1&gt;Method&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;API:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Percolation&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Percolation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;               &lt;span class="c1"&gt;// create N-by-N grid, with all sites blocked&lt;/span&gt;
   &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;          &lt;span class="c1"&gt;// open site (row i, column j) if it is not open already&lt;/span&gt;
   &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;boolean&lt;/span&gt; &lt;span class="n"&gt;isOpen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;     &lt;span class="c1"&gt;// is site (row i, column j) open?&lt;/span&gt;
   &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;boolean&lt;/span&gt; &lt;span class="n"&gt;isFull&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;     &lt;span class="c1"&gt;// is site (row i, column j) full?&lt;/span&gt;
   &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;boolean&lt;/span&gt; &lt;span class="n"&gt;percolates&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;             &lt;span class="c1"&gt;// does the system percolate?&lt;/span&gt;
   &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;   &lt;span class="c1"&gt;// test client (optional)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Corner cases: the row and column indices i and j are integers between 1 and N. &lt;strong&gt;1≤i,j≤N&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;if i/j out of range: &lt;code&gt;java.lang.IndexOutOfBoundsException&lt;/code&gt;
if N&amp;lt;=0 in constructor: &lt;code&gt;java.lang.IllegalArgumentException&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Performance requirements: N2 for constructor, const for other operations&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Monte Carlo simulation&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;all sites init to be closed&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;→ randomly choose a blocked site (i,j) and open it 
→ &lt;em&gt;repeat until percolates&lt;/em&gt; ⇒ the fraction of opened sites is an estimation of p*&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ex. 20*20 grid, when percolated: &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="file:///home/wx/Dropbox/ZIM_NOTES/0._TmpNotes/Algorithms%2C_4th_ed/Week1-Assignment-Percolation/pasted_image002.png" /&gt; &lt;br /&gt;
⇒ estimated p* = 204/400=0.51&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;repeat the estimation for T times, get T estimations &lt;/p&gt;
&lt;p&gt;→ get mean and std:  &lt;br /&gt;
&lt;img alt="" src="file:///home/wx/Dropbox/ZIM_NOTES/0._TmpNotes/Algorithms%2C_4th_ed/Week1-Assignment-Percolation/pasted_image003.png" /&gt; &lt;br /&gt;
→ 95% 置信区间: &lt;br /&gt;
&lt;img alt="" src="file:///home/wx/Dropbox/ZIM_NOTES/0._TmpNotes/Algorithms%2C_4th_ed/Week1-Assignment-Percolation/pasted_image004.png" /&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;create API for this simulation: &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;PercolationStats&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;PercolationStats&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;     &lt;span class="c1"&gt;// perform T independent experiments on an N-by-N grid&lt;/span&gt;
   &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;mean&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;                      &lt;span class="c1"&gt;// sample mean of percolation threshold&lt;/span&gt;
   &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;stddev&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;                    &lt;span class="c1"&gt;// sample standard deviation of percolation threshold&lt;/span&gt;
   &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;confidenceLo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;              &lt;span class="c1"&gt;// low  endpoint of 95% confidence interval&lt;/span&gt;
   &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;confidenceHi&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;              &lt;span class="c1"&gt;// high endpoint of 95% confidence interval&lt;/span&gt;
   &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;    &lt;span class="c1"&gt;// test client (described below)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;-if  N ≤ 0 or T ≤ 0: &lt;code&gt;java.lang.IllegalArgumentException&lt;/code&gt;&lt;br /&gt;
-&lt;code&gt;main()&lt;/code&gt; : takes two command-line arguments N and T&lt;br /&gt;
⇒ performs T independent computational experiments on an N-by-N grid, and prints out the mean, standard deviation, and the 95% confidence interval for p*. &lt;br /&gt;
(Use &lt;a href="http://introcs.cs.princeton.edu/java/stdlib/javadoc/StdRandom.html"&gt;standard random&lt;/a&gt; from our standard libraries to generate random numbers; use &lt;a href="http://introcs.cs.princeton.edu/java/stdlib/javadoc/StdStats.html"&gt;standard statistics&lt;/a&gt; to compute the sample mean and standard deviation. &lt;br /&gt;
Here is the algo API: &lt;a href="http://algs4.cs.princeton.edu/code/index.php"&gt;http://algs4.cs.princeton.edu/code/index.php&lt;/a&gt;)  &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Code&lt;/h1&gt;
&lt;p&gt;注意一定要用它们提供的那些库, 否则自己写的话代码就长了.... &lt;br /&gt;
shuffle, mean, stddev什么的直接用他们的函数库就可以做到. &lt;br /&gt;
&lt;a href="http://algs4.cs.princeton.edu/code/index.php"&gt;http://algs4.cs.princeton.edu/code/index.php&lt;/a&gt; &lt;br /&gt;
另外UF也是用他们写好的, WeightedQuickUnionUF.   &lt;/p&gt;
&lt;p&gt;按照提示, 除了格子的N^2个节点以外再增加两个节点: 顶部和底部的虚拟节点. 这里写的时候注意一开始也是不恩能够把它们与第一行/最后一行相连的 — 要在一个格子open以后再相连. &lt;/p&gt;
&lt;h3&gt;backwash问题&lt;/h3&gt;
&lt;p&gt;这次题目有一点比较困难就是, 需要实现isFull()函数, 这个函数判断一个格子(i,j)是否和顶部相连. 这里如果直接用UF的connected()判断是否和顶部虚拟节点相连的话是有问题的, 如下图: &lt;br /&gt;
&lt;img alt="" src="file:///home/wx/Dropbox/ZIM_NOTES/0._TmpNotes/Algorithms%2C_4th_ed/Week1-Assignment-Percolation/pasted_image005.png" /&gt; &lt;br /&gt;
白色格子表示格子是open的, 蓝色格子表示格子是open并且是&lt;em&gt;full&lt;/em&gt;的(i.e. 和顶部相连的), 左边图片里的状态是对的, 右边图片里底下部分的格子状态则不对: 如左下角的格子, 其实是没有和顶部联通的, 如果我们用两个虚拟节点的话, 由于底部虚拟节点和顶部虚拟节点相连, 所以和底部虚拟节点相连的左下角部分就被判断成了full的. &lt;/p&gt;
&lt;p&gt;这个问题一开始我以为可以很简单解决, 后来发现没那么容易... (注意题目还要求isFull()也要在常数时间给出结果).&lt;br /&gt;
一个不优雅的办法是, 建立两个UF, 一个用来判断percolation, 另一个UF里没有底部虚拟节点所以可以专门用来判断isFull(). &lt;/p&gt;
&lt;p&gt;这样解决的话使可以通过测试, 不过非常不好看, 另外一个UF的内存占用是8N^2(内部有size[]和id[]两个int数组), 比较大. &lt;/p&gt;
&lt;p&gt;在论坛上找了半天, 看了一些人的分享终于想到了这个非常妙的办法: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;UF只建立顶部虚拟节点, 不建立底部虚拟节点. &lt;/li&gt;
&lt;li&gt;判断isFull只需要用UF的connected()一下就好了&lt;/li&gt;
&lt;li&gt;问题是怎么判断percolation: &lt;br /&gt;
    a. 建立一个数组 &lt;code&gt;boolean connectedToBottom[]&lt;/code&gt;, 指示某一点是否和底部相连 &lt;br /&gt;
    b. trick在这里: 不必修改一个联通分支的所有点的&lt;code&gt;connectedToBottom&lt;/code&gt;的值, &lt;strong&gt;只需要修改联通分支的root(UF的find)即可&lt;/strong&gt;. 在进行union的时候先查看两个component的root是不是连到底部, 然后有一个连到底部的话, 在union以后把合并后的联通分支的&lt;code&gt;connectedToBottom&lt;/code&gt;状态改为true即可 &lt;br /&gt;
    c. 然后判断percolate: 先找到顶部虚拟节点锁在component的root, 然后看这个root是否连到底部即可!   &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样用一个boolean数组(N^2内存)代替了一个新的UF(8N^2内存), 而且实现也更加优雅.  &lt;br /&gt;
非常有意思的练习...&lt;/p&gt;</summary><category term="algorithm"></category></entry><entry><title>[Algorithms I] Week 1-2 Analysis of Algorithms</title><link href="http://x-wei.github.io/algoI_week1_2.html" rel="alternate"></link><updated>2015-07-02T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/algoI_week1_2.html</id><summary type="html">&lt;h1&gt;1. Introduction&lt;/h1&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week1_2/pasted_image.png" /&gt;&lt;/p&gt;
&lt;h1&gt;2. Observations&lt;/h1&gt;
&lt;p&gt;ex. &lt;strong&gt;3-SUM pb&lt;/strong&gt;&lt;br /&gt;
&lt;em&gt;given N distinct numbers, how many triples sum up to 0? (pb related to computatioal geogtry)&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;brute force method:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;mesuring running time:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;stdlib.jar里面提供了一个&lt;code&gt;Stopwatch&lt;/code&gt;类用于记录运行时间.  &lt;br /&gt;
&lt;img alt="" src="algoI_week1_2/pasted_image001.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;log-log plot&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;T(N) = running time for input of size N&lt;br /&gt;
log(N)-log(T(N)) plot:&lt;br /&gt;
often get a straight line — power law  &lt;br /&gt;
&lt;img alt="" src="algoI_week1_2/pasted_image002.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;doubling ratio&lt;/strong&gt;:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(for checking the power law relationship, checking the power order)&lt;br /&gt;
each time double the size of input, then take log of the time ratio of 2 runs: log( T(2N)/T(N) )  &lt;br /&gt;
&lt;img alt="" src="algoI_week1_2/pasted_image003.png" /&gt;  &lt;/p&gt;
&lt;h1&gt;3.Mathematical Models&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;total running time: sum of cost*frequency of operations &lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cost of some basic operations:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;array allocation: c*N (because all array entries have to be set to 0/false/null)&lt;/li&gt;
&lt;li&gt;string concatenation: c*N (proportional to the length  of string !)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;simplification&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;crude analysis&lt;br /&gt;
ignore lower terms &lt;strong&gt;tilde notation&lt;/strong&gt;  &lt;br /&gt;
&lt;img alt="" src="algoI_week1_2/pasted_image005.png" /&gt;  &lt;br /&gt;
&lt;img alt="" src="algoI_week1_2/pasted_image004.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;estimating discrete sum by relaxation&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Replace the sum with an integral, and use calculus — 很机智...   &lt;br /&gt;
&lt;img alt="" src="algoI_week1_2/pasted_image006.png" /&gt;&lt;/p&gt;
&lt;h1&gt;4. Order of Growth Classification&lt;/h1&gt;
&lt;p&gt;(discard the leading coefficient when considering the growth order)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;only a small set of growth functions: &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;1, logN, N, NlogN, N^2, N^3, 2^N&lt;/code&gt; &lt;br /&gt;
&lt;img alt="" src="algoI_week1_2/pasted_image007.png" /&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;exemples:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;binary search ⇒ logN&lt;br /&gt;
divide and conquer ⇒ NlogN&lt;br /&gt;
exhaustive search ⇒ 2^N &lt;br /&gt;
&lt;img alt="" src="algoI_week1_2/pasted_image008.png" /&gt;&lt;/p&gt;
&lt;p&gt;practical performance: &lt;br /&gt;
&lt;img alt="" src="algoI_week1_2/pasted_image009.png" /&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;ex. &lt;strong&gt;binary search&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;public int binearch(int arr[], int key){//arr[] already sorted
    int lo=0,hi=arr.length;
    while(i&amp;lt;j){
        int m = (lo+hi)/2;
        if(arr[m]==key) return m;
        else if(arr[m]&amp;lt;key) lo=m+1;
        else hi=m-1;
    }
    return -1;
}&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(→ Bug in Java's Arrays.binarySearch() discovered in 2006......) &lt;br /&gt;
→ invariant: if key in arr, arr[lo]&amp;lt;=key&amp;lt;=arr[hi] &lt;br /&gt;
&lt;strong&gt;proposition. &lt;/strong&gt;binary search uses at most logN+1 compares to search a sorted array of size N.
&lt;strong&gt;pf. &lt;/strong&gt;
denote &lt;em&gt;T(N)&lt;/em&gt; := nb of compares for array with size &amp;lt;=N&lt;br /&gt;
→ T(1)=1&lt;br /&gt;
→ recurrence relation: T(N)&amp;lt;=T(N/2)+1&lt;br /&gt;
⇒ T(N)=logN  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;a faster 3-SUM&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;→ first sort the array &lt;em&gt;(~NlogN)&lt;/em&gt;&lt;br /&gt;
→ for any pair a[i] and a[j], do binary search for -(a[i]+a[j])   &lt;em&gt;~(N2LogN)&lt;/em&gt;&lt;br /&gt;
⇒ reduce from N3 to N2logN ! (for 8k numbers, running time goes from 51s to 0.96s)  &lt;/p&gt;
&lt;h1&gt;5. Theory of Algorithms&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;types of analysis&lt;/p&gt;
&lt;p&gt;-best case
-worst case
-average case(random input, "expected cost")&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;notations&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;big Theta/big O/big Omega&lt;/strong&gt;  &lt;br /&gt;
&lt;img alt="" src="algoI_week1_2/pasted_image010.png" /&gt;   &lt;br /&gt;
    - big O: &lt;em&gt;upper bound  → * once a specific algo is found, find an upper bound&lt;br /&gt;
    - big Omega: &lt;/em&gt;lower bound   &lt;em&gt;→ proove that no algo can do better&lt;br /&gt;
    - big Theta: symptotic growth (same order, optimal algo)  → lower and upper bound &lt;/em&gt;match* &lt;br /&gt;
&lt;img alt="" src="algoI_week1_2/pasted_image011.png" /&gt;   &lt;br /&gt;
⇒ in this course: use tilde notation: contain leading constants for highest order term&lt;/p&gt;
&lt;h1&gt;6. Memory&lt;/h1&gt;
&lt;p&gt;KB: 2^10 bytes&lt;br /&gt;
MB: 2^20 bytes (1 million) 
GB: 2^30 bytes (1 billion) 
64-bit machines: &lt;em&gt;8 byte pointers&lt;/em&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;typical memory usage:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;for primary types: &lt;br /&gt;
&lt;img alt="" src="algoI_week1_2/pasted_image012.png" /&gt;&lt;br /&gt;
for arrays  (with &lt;em&gt;array overhead=24bytes&lt;/em&gt;) :  &lt;br /&gt;
&lt;img alt="" src="algoI_week1_2/pasted_image013.png" /&gt; &lt;br /&gt;
&lt;em&gt;Obj overhead: 16 bytes&lt;/em&gt; (obj的大小=16+obj内部filed的大小)&lt;br /&gt;
&lt;em&gt;references&lt;/em&gt;: 8 bytes (ex. inner class has a ref to encolsing class)&lt;br /&gt;
&lt;em&gt;padding&lt;/em&gt;: each obj uses a multiply of 8 bytes (obj大小=8 bytes的整数倍)    &lt;br /&gt;
&lt;img alt="" src="algoI_week1_2/pasted_image014.png" /&gt;   &lt;br /&gt;
&lt;img alt="" src="algoI_week1_2/pasted_image015.png" /&gt;     &lt;/p&gt;</summary><category term="algorithm"></category></entry><entry><title>[Spark MOOC note] lab4. Predicting Movie Ratings</title><link href="http://x-wei.github.io/sparkmooc_notelab4.html" rel="alternate"></link><updated>2015-06-30T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/sparkmooc_notelab4.html</id><summary type="html">&lt;h1&gt;Part 0: Preliminaries&lt;/h1&gt;
&lt;p&gt;Each line in the ratings dataset (&lt;em&gt;ratings.dat.gz&lt;/em&gt;) is formatted as: &lt;br /&gt;
&lt;code&gt;UserID::MovieID::Rating::Timestamp&lt;/code&gt; ⇒ tuples of &lt;code&gt;(UserID, MovieID, Rating)&lt;/code&gt;in &lt;em&gt;ratingsRDD&lt;/em&gt; &lt;br /&gt;
Each line in the movies (&lt;em&gt;movies.dat&lt;/em&gt;) dataset is formatted as: &lt;br /&gt;
&lt;code&gt;MovieID::Title::Genres&lt;/code&gt; ⇒ tuples of &lt;code&gt;(MovieID, Title)&lt;/code&gt; in &lt;em&gt;ratingsRDD&lt;/em&gt;    &lt;/p&gt;
&lt;p&gt;487650 ratings and 3883 movies&lt;/p&gt;
&lt;p&gt;⇒ Since the key is an integer and the value is a unicode string, we can use a function to combine them into a single unicode string (e.g., &lt;code&gt;unicode('%.3f' % key) + ' ' + value&lt;/code&gt;) before sorting the RDD using &lt;code&gt;sortBy()&lt;/code&gt;.&lt;/p&gt;
&lt;h1&gt;Part 1: Basic Recommendations&lt;/h1&gt;
&lt;p&gt;naive method: &lt;em&gt;always recommend the movies with the highest average rating...&lt;/em&gt;
⇒ 20 movies with the highest average rating and more than 500 reviews&lt;/p&gt;
&lt;p&gt;&lt;em&gt;movieNameWithAvgRatingsRDD&lt;/em&gt;: &lt;code&gt;(avgRating, Title, nbRatings)&lt;/code&gt;&lt;/p&gt;
&lt;h1&gt;Part 2: Collaborative Filtering&lt;/h1&gt;
&lt;p&gt;MLlib: &lt;a href="https://spark.apache.org/mllib/"&gt;https://spark.apache.org/mllib/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Collaborative filtering&lt;/em&gt; is a method of making automatic predictions (filtering) about the interests of a user by collecting preferences or taste information from many users (collaborating). The underlying assumption of the collaborative filtering approach is that if a person A has the same opinion as a person B on an issue, A is more likely to have B's opinion on a different issue x than to have the opinion on x of a person chosen randomly. &lt;/p&gt;
&lt;p&gt;一图胜千言: &lt;br /&gt;
&lt;img alt="" src="sparkmooc_note_lab4/Collaborative_filtering.gif" /&gt;&lt;/p&gt;
&lt;h3&gt;Matrix Factorization&lt;/h3&gt;
&lt;p&gt;CF问题实际上是矩阵分解的问题: 
We have a matrix whose entries are movie ratings by users (shown in red in the diagram below). Each column represents a user (shown in green) and each row represents a particular movie (shown in blue).&lt;/p&gt;
&lt;p&gt;其中&lt;em&gt;rating矩阵&lt;/em&gt;(用户/电影矩阵)只有一些项的值存在(即用户打分的那些项), 所以要用分解后的两个矩阵之乘积来估计rating矩阵中的缺失项.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;With collaborative filtering, the idea is to approximate the ratings matrix by factorizing it as the product of two matrices: one that describes properties of each user (shown in green), and one that describes properties of each movie (shown in blue).&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="sparkmooc_note_lab4/pasted_image002.png" /&gt;&lt;/p&gt;
&lt;p&gt;若N个用户, M个电影 ⇒ 把rating矩阵(N&lt;em&gt;M)分解为 一个N&lt;/em&gt;d矩阵(&lt;em&gt;user矩阵&lt;/em&gt;)与一个d&lt;em&gt;M(&lt;/em&gt;movie矩阵*)矩阵之积. &lt;/p&gt;
&lt;p&gt;其中d个维度可以有(隐含的)意义: 比如f[j]第一个维度代表了电影j中动作片的成分, f[i]的第一个维度表示用户i对动作片的喜爱程度, 以此类推... 所以f[i]与f[j]的内积就可以是用户i对电影j的评分的一个不错的预测. &lt;/p&gt;
&lt;p&gt;假设&lt;em&gt;f[j]已知&lt;/em&gt;, 那么f[i]要满足: 对那些用户i已经打过分的电影(即r_ij存在)上的估计偏差最小:   &lt;br /&gt;
&lt;img alt="" src="sparkmooc_note_lab4/pasted_image.png" /&gt;    &lt;br /&gt;
(后面加上的那一项是正则项: 不希望f[i]的模过大)&lt;/p&gt;
&lt;p&gt;不过前面的假设, "f[j]已知"这个条件其实并不成立 ⇒ &lt;strong&gt;Alternating Least Squares algorithm&lt;/strong&gt;: 交替优化f[i]和f[j]的取值, 每次固定一个, 而优化另一个, 交替进行, 直到收敛(好像Kmeans也是利用的这种方法). &lt;/p&gt;
&lt;p&gt;&lt;em&gt;first randomly filling the users matrix with values and then optimizing the value of the movies such that the error is minimized. Then, it holds the movies matrix constrant and optimizes the value of the user's matrix.&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;train-test-validation split&lt;/h3&gt;
&lt;p&gt;⇒ break up the ratingsRDD dataset into three pieces:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A training set (RDD), which we will use to train models&lt;/li&gt;
&lt;li&gt;A validation set (RDD), which we will use to choose the best model&lt;/li&gt;
&lt;li&gt;A test set (RDD), which we will use for our experiments&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;trainingRDD, validationRDD, testRDD = ratingsRDD.randomSplit([6, 2, 2], seed=0L)&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;Root Mean Square Error (RMSE)&lt;/h3&gt;
&lt;p&gt;&lt;img alt="" src="sparkmooc_note_lab4/pasted_image003.png" /&gt;  &lt;br /&gt;
compute the sum of squared error given predictedRDD and actualRDD RDDs. 
Both RDDs consist of tuples of the form (UserID, MovieID, Rating)&lt;/p&gt;
&lt;h3&gt;alternating least square of MLllib&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://spark.apache.org/docs/latest/api/python/pyspark.mllib.html#pyspark.mllib.recommendation.ALS"&gt;https://spark.apache.org/docs/latest/api/python/pyspark.mllib.html#pyspark.mllib.recommendation.ALS&lt;/a&gt;
ALS takes a training dataset (RDD) and several parameters that control the model creation process.&lt;/p&gt;
&lt;p&gt;The most important parameter to ALS.train() is the &lt;em&gt;rank&lt;/em&gt;, which is the number of rows in the Users matrix (green in the diagram above) or the number of columns in the Movies matrix (blue in the diagram above). (In general, a lower rank will mean higher error on the training dataset, but a high rank may lead to overfitting.)&lt;/p&gt;
&lt;p&gt;貌似ALS接受一个(userid, itemid, rating)的RDD作为输入, 预测时接受一个(userid, itemid)的RDD作为输入, 返回一个(userid, itemid, rating)的RDD.  (也就是说, 前面的notation在这里继续被使用了).&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;model&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ALS&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;train&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;trainingRDD&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rank&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;seed&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;seed&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;iterations&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;iterations&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                      &lt;span class="n"&gt;lambda_&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;regularizationParameter&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;predictedRatingsRDD&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;predictAll&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;validationForPredictRDD&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以在这里查看job详情: &lt;a href="http://localhost:4040/jobs/"&gt;http://localhost:4040/jobs/&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;compare model&lt;/h3&gt;
&lt;p&gt;Looking at the RMSE for the results predicted by the model versus the values in the test set is one way to evalute the quality of our model. &lt;em&gt;Another way to evaluate the model is to evaluate the error from a test set where every rating is the average rating for the training set.&lt;/em&gt;
⇒ 这里没有太理解, 难道是说test set 的平均rating预测结果和training set的平均rating应该比较接近么?? 
⇒ 终于明白了: "&lt;em&gt;Your model more accurately predicts the ratings than using just the average rating, as the model's RMSE is significantly lower than the RMSE when using the average rating.&lt;/em&gt;"&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;求一个tuple rdd最后一列的和的时候, 需要先map成最后一列再reduce: &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;trainingRDD.map(lambda x:x[-1]).reduce(lambda x,y:x+y)&lt;/code&gt;&lt;br /&gt;
直接写&lt;code&gt;reduce(lambda x,y:x[-1]+y[-1])&lt;/code&gt;貌似是不行的&lt;/p&gt;</summary><category term="spark"></category></entry><entry><title>[Algorithms I] Week 1-1 Union-Find</title><link href="http://x-wei.github.io/algoI_week1_1.html" rel="alternate"></link><updated>2015-06-27T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/algoI_week1_1.html</id><summary type="html">&lt;h1&gt;1. Dynamic Connectivity pb&lt;/h1&gt;
&lt;h3&gt;pb statement&lt;/h3&gt;
&lt;p&gt;a set of N obj, &lt;em&gt;indexed by 0,1,...,N-1&lt;/em&gt;
⇒ 
&lt;em&gt; UNION: connect objects &lt;code&gt;void union(int p, int q)&lt;/code&gt;
&lt;/em&gt; FIND: is there a path connecting 2 obj?  &lt;code&gt;boolean connected(int p, int q)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;ex: &lt;br /&gt;
&lt;img alt="" src="algoI_week1_1/pasted_image.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;connect components&lt;/strong&gt;(联通分支): max set of obj that are mutually connected. &lt;/p&gt;
&lt;h3&gt;UF API&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;union(p,q): connect 2 obj&lt;/li&gt;
&lt;li&gt;connected(p,q): test if p and q are connected &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;find(p)&lt;/strong&gt;: find the &lt;em&gt;component id&lt;/em&gt; of p&lt;/li&gt;
&lt;li&gt;count(): nb of components&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意:
命名不是很好, 这里的&lt;code&gt;find()&lt;/code&gt;函数不对应FIND query, &lt;code&gt;connected()&lt;/code&gt;函数才是真正的FIND query, find()函数是为了connected()函数而做的一个辅助函数(find(p): return the root of the node p )
在connected里就可以调用find: &lt;code&gt;return find(p)==find(q)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;应该是interface更好一些... &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;interface&lt;/span&gt; &lt;span class="n"&gt;UF&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="k"&gt;union&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;boolean&lt;/span&gt; &lt;span class="nf"&gt;connected&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;//int find(int p);&lt;/span&gt;
&lt;span class="c1"&gt;//int count();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;测试client: &lt;br /&gt;
&lt;img alt="" src="algoI_week1_1/pasted_image003.png" /&gt;&lt;/p&gt;
&lt;h1&gt;2. Quick Find&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;"eager approach"&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;data structure&lt;/h3&gt;
&lt;p&gt;⇒ an int array &lt;code&gt;id[]&lt;/code&gt;
initialized to &lt;em&gt;id[p]=p for all p&lt;/em&gt;
interpretation: &lt;em&gt;id[p] = &lt;strong&gt;&lt;em&gt;component id of obj p&lt;/em&gt;&lt;/strong&gt;
⇒ p and q are connected &lt;/em&gt;iff* id[p]==id[q] (ie. find very fast)
没有用find()函数  &lt;br /&gt;
&lt;img alt="" src="algoI_week1_1/pasted_image002.png" /&gt;  &lt;/p&gt;
&lt;h3&gt;UF operations&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;FIND:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;connected(p,q):&lt;/code&gt; very fast, just check id[p] and id[q]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UNION:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;when merging 2 components :
&lt;code&gt;union(p,q)&lt;/code&gt;: &lt;code&gt;id[p]=id[q]&lt;/code&gt;(总是让第一个参数p的id变为第二个参数q的id), &lt;br /&gt;
⇒ then have to modify &lt;em&gt;all entries&lt;/em&gt; with id equal to &lt;code&gt;id[p]&lt;/code&gt; !&lt;br /&gt;
⇒ too many entries to change  &lt;/p&gt;
&lt;h3&gt;implementation&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;(class  QuickFindUF implements UF)&lt;/em&gt;&lt;br /&gt;
&lt;img alt="" src="algoI_week1_1/pasted_image004.png" /&gt;&lt;/p&gt;
&lt;p&gt;complexity: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FIND: cte&lt;/li&gt;
&lt;li&gt;UNION: lin...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;if N obj + N unions ⇒ &lt;em&gt;quad time !&lt;/em&gt;&lt;br /&gt;
btw, 程序运行速度: &lt;strong&gt;~10^9/s&lt;/strong&gt;&lt;/p&gt;
&lt;h1&gt;3. Quick Union&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;"lazy approach"&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;data structure&lt;/h3&gt;
&lt;p&gt;⇒ also an int array &lt;code&gt;id[]&lt;/code&gt;
considering a set of &lt;em&gt;trees, &lt;/em&gt;此时每个联通分支都是一个tree&lt;br /&gt;
interpretation: &lt;em&gt;id[p] = &lt;em&gt;&lt;strong&gt;parent index of obj p &lt;/strong&gt;(觉得这个数组叫做father更好....)&lt;br /&gt;
⇒ p is a root node &lt;/em&gt;iff&lt;/em&gt; id[p]==p&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week1_1/pasted_image005.png" /&gt;&lt;/p&gt;
&lt;h3&gt;UF operations&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;FIND:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;connected(p,q):&lt;/code&gt;check if &lt;em&gt;root of p == root of q&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UNION: &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;union(p,q):&lt;/code&gt;just set p's root to be &lt;em&gt;child&lt;/em&gt; of q's root (把第一个参数p的那棵树放入第二个参数q的树的根节点作为子树)&lt;br /&gt;
&lt;img alt="" src="algoI_week1_1/pasted_image006.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;root():&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前两个的操作都需要一个函数查找一个节点的root,  需要写一个函数实现, 也很简单, 一路找parent即可:   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;root&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;implementation&lt;/h3&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week1_1/pasted_image007.png" /&gt;&lt;/p&gt;
&lt;h3&gt;complexity&lt;/h3&gt;
&lt;p&gt;in the worst case (all elements is in a list form), root() is ~N, so:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FIND: lin&lt;/li&gt;
&lt;li&gt;UNION: lin&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;quick find和quick union的问题: &lt;br /&gt;
&lt;img alt="" src="algoI_week1_1/pasted_image009.png" /&gt;&lt;/p&gt;
&lt;h1&gt;4. Quick Union Improvements&lt;/h1&gt;
&lt;h2&gt;improvement1: weighting&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;keep track of tree size&lt;/em&gt; ⇒ balance by taking the small tree be a child of the large tree  &lt;br /&gt;
&lt;img alt="" src="algoI_week1_1/pasted_image010.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week1_1/pasted_image011.png" /&gt;&lt;/p&gt;
&lt;p&gt;⇒ add an extra array: &lt;code&gt;sz[]&lt;/code&gt; sz[i] is the size of the tree with root i&lt;/p&gt;
&lt;h3&gt;implementation&lt;/h3&gt;
&lt;p&gt;(数组&lt;code&gt;int  sz[]&lt;/code&gt; 初始全部为1)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;依然需要&lt;code&gt;root()&lt;/code&gt;函数.&lt;/p&gt;
&lt;p&gt;private int root(int p){
    while(p!=id[p]) p=id[p];
    return p;
}&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FIND &lt;/p&gt;
&lt;p&gt;public boolean connected(int p, int q){
    return root(p)==root(q);
}&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UNION&lt;/p&gt;
&lt;p&gt;public void  union(int p, int q){
    int rp = root(p), rq=root(q);
    if(rp==rq) return; // 
    if (sz[rp]&amp;lt;sz[rq]){
        id[rp]=rq;
        sz[rq]+=sz[rp];
    }
    else{...}
}&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;complexity&lt;/h3&gt;
&lt;p&gt;FIND: proportional to &lt;em&gt;depth of p and&lt;/em&gt; q in their tree
UNION: const if p and q are root&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;proposition&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;the max depth of weightedQuickUnion is &lt;strong&gt;lgN&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[pf] considering a node &lt;code&gt;x&lt;/code&gt;, in tree &lt;code&gt;T1&lt;/code&gt;, &lt;code&gt;dep(x)&lt;/code&gt; is x's depth in its tree.  &lt;br /&gt;
&lt;img alt="" src="algoI_week1_1/pasted_image012.png" /&gt; &lt;br /&gt;
→   &lt;code&gt;dep(x)&lt;/code&gt; will increase by 1, iff &lt;code&gt;T1&lt;/code&gt; is merged into another tree &lt;code&gt;T2&lt;/code&gt; (and by the algo, shoud have |T1|&amp;lt;=|T2| )&lt;br /&gt;
→   x's tree's size become |T1|+|T2| &amp;gt;= 2&lt;em&gt;|T1| 
⇒   everytime dep(x) increased by 1, x's tree's size will &lt;/em&gt;at least double*&lt;br /&gt;
at first dep(x)=1, if dep(x) increases lgN times, the size of the tree will be &amp;gt;=  N &lt;br /&gt;
CQFD.&lt;/p&gt;
&lt;p&gt;so the &lt;code&gt;root()&lt;/code&gt; function takes only lgN time. 
&lt;strong&gt;conclusion&lt;/strong&gt;: both UNION and FIND will be in &lt;strong&gt;lgN &lt;/strong&gt;time. &lt;/p&gt;
&lt;h2&gt;improvement 2: path compression&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;imporve the root() function: &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;when looking for root of a node ⇒ link &lt;em&gt;all nodes in the path &lt;/em&gt;up to the root. &lt;br /&gt;
⇒ just a constant extra time compared to old implementation. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;2 pass implementation: &lt;/p&gt;
&lt;p&gt;private int root(int p){
    int r = p;
    while(r!=id[r]) r=id[r];
    while(p!=r){
        int t = p;
        p=id[p];
        id[t]=r;
    }
    return r;
}&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;flatens the tree greatly. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;single pass implementation: &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;just make all other node &lt;em&gt;point to its grandparent&lt;/em&gt; (halving the path length)
⇒ not as flatening as before, but in practice will almost be the same. 
just one extra line of code: 
    private int root(int p){
        while(p!=id[p]){ 
            id[p] = id[ id[p] ];
            p=id[p];  &lt;br /&gt;
        }
        return p;
    }&lt;/p&gt;
&lt;h3&gt;complexity&lt;/h3&gt;
&lt;p&gt;(for weighet quick union with path compression — &lt;em&gt;WQUPC&lt;/em&gt;)&lt;br /&gt;
very very small: &lt;br /&gt;
&lt;img alt="" src="algoI_week1_1/pasted_image013.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;lg*()&lt;/strong&gt; function: "&lt;em&gt;iterated log function&lt;/em&gt;", lg&lt;em&gt;(N) = the number of time to take log to get to 1
lg&lt;/em&gt;()几乎可以看成常数了:  &lt;br /&gt;
&lt;img alt="" src="algoI_week1_1/pasted_image014.png" /&gt; &lt;br /&gt;
ex. &lt;em&gt;lg&lt;/em&gt;(65536) = 4* (x^16=65536)&lt;br /&gt;
because: lg(65536)=16 ; lg(16) = 4; lg(4)=2; lg(2)=1. &lt;br /&gt;
&lt;strong&gt;⇒ N obj, M unions will take (almost) linear time&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week1_1/pasted_image015.png" /&gt; &lt;br /&gt;
(有人证明了不存在&lt;em&gt;理论上&lt;/em&gt;linear的算法. )&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;conclusion&lt;/strong&gt;: both UNION and FIND will be in &lt;strong&gt;constant time&lt;/strong&gt;.&lt;/p&gt;
&lt;h2&gt;summery&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week1_1/pasted_image017.png" /&gt; &lt;br /&gt;
上面这个表格好像quick union的部分有问题? 最坏情况下应该是N+MN吧??&lt;br /&gt;
书上是这么写的:  &lt;br /&gt;
&lt;img alt="" src="algoI_week1_1/pasted_image016.png" /&gt;&lt;/p&gt;
&lt;p&gt;WQUCF reduce 30 years to 6 seconds. &lt;/p&gt;
&lt;h1&gt;5. Union Find Application&lt;/h1&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week1_1/pasted_image018.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;percolation&lt;/li&gt;
&lt;li&gt;dynamic connectivity&lt;/li&gt;
&lt;li&gt;Kruskal MST algo&lt;/li&gt;
&lt;li&gt;Games (GO)&lt;/li&gt;
&lt;li&gt;.......&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;percolation&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;model: &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;N&lt;em&gt;N grid of sites&lt;br /&gt;
⇒ each site is open with proba=&lt;/em&gt;p*&lt;br /&gt;
⇒ sys &lt;strong&gt;percolate&lt;/strong&gt; iff bottom and top are connected by open sites.  &lt;br /&gt;
&lt;img alt="" src="algoI_week1_1/pasted_image019.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;question: the &lt;em&gt;percolation probability&lt;/em&gt; as a function of &lt;em&gt;p &lt;/em&gt;(&lt;strong&gt;phase transition&lt;/strong&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week1_1/pasted_image020.png" /&gt; &lt;br /&gt;
nobody knows how to get the threshold mathematically&lt;br /&gt;
⇒ run &lt;em&gt;simulations&lt;/em&gt; to find out the phase transition &lt;em&gt;threshold&lt;/em&gt;.   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Monte Carlo simulation   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;→ all sites initilized to be &lt;em&gt;closed&lt;/em&gt;&lt;br /&gt;
→ randomly open sites &lt;em&gt;one by one&lt;/em&gt; &lt;br /&gt;
→ when the sys percolates, the &lt;em&gt;vacancy percentage&lt;/em&gt; is an estimate of &lt;em&gt;p&lt;/em&gt; &lt;br /&gt;
*(run above simulation for millions of times)   &lt;/p&gt;
&lt;h3&gt;implementation&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;N^2 sites, named 0 to N^2-1  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week1_1/pasted_image022.png" /&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;add 2 more vertual sites: one on top, one on bottom   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week1_1/pasted_image021.png" /&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;openning a site: union to adjcent open sites (at most 4 unions)&lt;/li&gt;
&lt;/ul&gt;</summary><category term="algorithm"></category></entry><entry><title>[Spark MOOC note] Lec8. Exploratory Data Analysis and Machine Learning</title><link href="http://x-wei.github.io/sparkmooc_note_lec8.html" rel="alternate"></link><updated>2015-06-23T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/sparkmooc_note_lec8.html</id><summary type="html">&lt;h2&gt;STATISTICS, BUSINESS QUESTIONS, AND LEARNING TECHNIQUES&lt;/h2&gt;
&lt;p&gt;2 different kinds of statistics: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;descriptive statistics&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ex. median — describes data, &lt;em&gt;but cannot generalize beyong that&lt;/em&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;inferential statistics&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ex. &lt;em&gt;t-testing — inferences beyond the data&lt;/em&gt;
techniques leveraged for machine learning and prediction&lt;/p&gt;
&lt;p&gt;supervised learning (clf, reg), unsupervised learning (clustering, dim-reduction)
 → UL often used in a larger SL pb (ex. &lt;em&gt;auto-encoder&lt;/em&gt;)&lt;br /&gt;
&lt;img alt="" src="sparkmooc_note_lec8/pasted_image.png" /&gt;&lt;/p&gt;
&lt;h2&gt;EXPLORATORY DATA ANALYSIS&lt;/h2&gt;
&lt;p&gt;5-number summary:&lt;/p&gt;
&lt;p&gt;The five-number summary is a descriptive statistic that provides information about a set of observations. It consists of the five most important sample percentiles:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The sample minimum (smallest observation)&lt;/li&gt;
&lt;li&gt;The lower quartile or first quartile&lt;/li&gt;
&lt;li&gt;The median (middle value)&lt;/li&gt;
&lt;li&gt;The upper quartile or third quartile&lt;/li&gt;
&lt;li&gt;The sample maximum (largest observation)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="sparkmooc_note_lec8/pasted_image001.png" /&gt;&lt;/p&gt;
&lt;p&gt;→ box plot: &lt;br /&gt;
&lt;img alt="" src="sparkmooc_note_lec8/pasted_image004.png" /&gt;&lt;/p&gt;
&lt;h2&gt;THE R LANGUAGE AND NORMAL DISTRIBUTIONS&lt;/h2&gt;
&lt;p&gt;R: intractive exploration and visulization of data + statistical models and distributions + CRAN&lt;/p&gt;
&lt;p&gt;Central Limit Th: sum/mean of n iid random variables 
many statistical test assume data to be normally distributed&lt;/p&gt;
&lt;h2&gt;DISTRIBUTIONS&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;poissons distribution: accurrence freq&lt;/li&gt;
&lt;li&gt;exponential distribution: interval between 2 (poissons) events&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Zipf/Pareto/Yule distributions&lt;/em&gt;: frequencies of different terms in a document, or web site visits&lt;/li&gt;
&lt;li&gt;binomial/multinomial distribution: nb of count of events&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;RHINE PARADOX&lt;/h2&gt;
&lt;h2&gt;SPARK'S MACHINE LEARNING TOOLKIT&lt;/h2&gt;
&lt;p&gt;mllib: scalable, distributed ML library, &lt;em&gt;sklearn-like&lt;/em&gt; ML toolkit
&lt;a href="https://spark.apache.org/docs/latest/mllib-guide.html"&gt;https://spark.apache.org/docs/latest/mllib-guide.html&lt;/a&gt;
lab: &lt;em&gt;collaborative filtering — &lt;/em&gt;matrix factorisation&lt;br /&gt;
&lt;img alt="" src="sparkmooc_note_lec8/pasted_image005.png" /&gt;&lt;br /&gt;
⇒ &lt;em&gt;alternating&lt;/em&gt; least square(ALS):  &lt;br /&gt;
&lt;img alt="" src="sparkmooc_note_lec8/pasted_image006.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;trouble with summary stats&lt;/strong&gt;: &lt;em&gt;Anscombe's Quartet&lt;/em&gt;
→ have same statistics property&lt;br /&gt;
&lt;img alt="" src="sparkmooc_note_lec8/pasted_image002.png" /&gt;&lt;br /&gt;
→ quite different in fact: &lt;br /&gt;
&lt;img alt="" src="sparkmooc_note_lec8/pasted_image003.png" /&gt;&lt;br /&gt;
&lt;strong&gt;Takeaways&lt;/strong&gt;:&lt;br /&gt;
&lt;em&gt;•  Important to look at data graphically before analyzing it   &lt;/em&gt;
&lt;em&gt;•  Basic statistics properties often fail to capture real-world complexities&lt;/em&gt;  &lt;/p&gt;
&lt;h2&gt;Lab3. Text Analysis and Entity Resolution&lt;/h2&gt;
&lt;p&gt;Entity Resolution (ER) refers to the task of finding records in a data set that refer to the same entity across different data sources (e.g., data files, books, websites, databases). ER is necessary when joining data sets based on entities that may or may not share a common identifier (e.g., database key, URI, National identification number), as may be the case due to differences in record shape, storage location, and/or curator style or preference. A data set that has undergone ER may be referred to as being cross-linked.&lt;/p&gt;
&lt;p&gt;The file format of an Amazon line is:
"id","title","description","manufacturer","price"
The file format of a Google line is:
"id","name","description","manufacturer","price"&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;re.split&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;re.split()有个很讨厌的地方: 字符串以句号等结尾时, 最后总是会出现一个空字符串:
    &amp;gt;&amp;gt;&amp;gt; re.split('\W+', 'Words, words, words.')
    ['Words', 'words', 'words', '']
解决办法就是用个filter:　
&lt;code&gt;filter(None,re.split(split_regex, string.lower()) )&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tfidf&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TF rewards tokens that appear many times in the same document. It is computed as the frequency of a token in a document. IDF rewards tokens that are rare overall in a dataset. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cosine similarity&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The metric of string distance we will use is called cosine similarity. We will treat each document as a vector in some high dimensional space. Then, to compare two documents we compute the cosine of the angle between their two document vectors. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;flatMap&lt;/code&gt;: 一行变多行, 别忘了...&lt;/li&gt;
&lt;li&gt;broadcast variable&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;we define the broadcast variable in the driver and then we can refer to it in each worker. Spark saves the broadcast variable at each worker, so it is only sent once.
声明广播变量的办法也很简单, 只要:
 &lt;code&gt;idfsSmallBroadcast = sc.broadcast(idfsSmallWeights)&lt;/code&gt;
然后用的时候要改成&lt;code&gt;xx.value&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;EXCEPT语句&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;找了一下没发现spark有SQL的EXCEPT语句(就是和join相反), 于是只好这么写了:
    nonDupsRDD = (sims
                  .leftOuterJoin(goldStandard)
                 .filter(lambda x: x[1][1]==None)
                 .map(lambda x:(x[0],x[1][0])))
用leftouterjoin 然后再只保留为None的那些... 应该不是最佳写法吧...&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;complexity&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用的ER办法(cosine similarity)的复杂度是O2 太高了...
⇒ An &lt;strong&gt;inverted index&lt;/strong&gt; is a data structure that will allow us to avoid making quadratically many token comparisons. It maps each token in the dataset to &lt;em&gt;the list of documents that contain the token&lt;/em&gt;. So, instead of comparing, record by record, each token to every other token to see if they match, we will use inverted indices to &lt;em&gt;look up records(documents) that match on a particular token&lt;/em&gt;.
这种操作的基础是: 有很多向量的support是完全不重合的 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;.&lt;code&gt;collectAsMap()&lt;/code&gt;: 把pair rdd变为map&lt;/li&gt;
&lt;li&gt;groupByKey(): 这个也用上了&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;lab4前后做了四个小时 不过很有意思... 第五部分出现out of memory error就没办法了...&lt;/p&gt;</summary><category term="spark"></category></entry><entry><title>[Spark MOOC note] Lec7. Data Quality</title><link href="http://x-wei.github.io/sparkmooc_note_lec7.html" rel="alternate"></link><updated>2015-06-22T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/sparkmooc_note_lec7.html</id><summary type="html">&lt;h2&gt;DATA CLEANING&lt;/h2&gt;
&lt;p&gt;ex. 
deal with missing data, entity resolution, unit mismatch, ... &lt;/p&gt;
&lt;p&gt;deal with non-ideal samples ⇒ tradeoff between simplicity and accuracy. &lt;/p&gt;
&lt;h2&gt;DATA QUALITY PROBLEMS&lt;/h2&gt;
&lt;p&gt;data quality problems: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Conversions in complex pipelines can mess up data &lt;/li&gt;
&lt;li&gt;Combining multiple datasets can result in errrors&lt;/li&gt;
&lt;li&gt;Data degrades in accuracy or loses value over time&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还提供了一些工具帮助cleaning data: &lt;a href="http://vis.stanford.edu/wrangler/"&gt;http://vis.stanford.edu/wrangler/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;EXAMPLE: AGES OF STUDENTS IN THIS COURSE&lt;/h2&gt;
&lt;p&gt;(students' ages are self-reported...)&lt;br /&gt;
&lt;img alt="" src="sparkmooc_note_lec7/pasted_image.png" /&gt;&lt;/p&gt;
&lt;h2&gt;DATA CLEANING MAKES EVERYTHING OKAY?&lt;/h2&gt;
&lt;p&gt;ex. the appearance of a hole in the ozone layer. &lt;/p&gt;
&lt;h2&gt;DIRTY DATA PROBLEMS&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" src="sparkmooc_note_lec7/pasted_image001.png" /&gt;&lt;/p&gt;
&lt;p&gt;Data Quality Continuum:&lt;br /&gt;
&lt;img alt="" src="sparkmooc_note_lec7/pasted_image002.png" /&gt;&lt;/p&gt;
&lt;h2&gt;DATA GATHERING&lt;/h2&gt;
&lt;p&gt;solutions in the data gathering stage: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;re-emptive (先发制人) &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;integrity checks&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;retrospective&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;duplicate removal&lt;/p&gt;
&lt;h2&gt;DATA DELIVERY&lt;/h2&gt;
&lt;p&gt;solutions: &lt;br /&gt;
&lt;img alt="" src="sparkmooc_note_lec7/pasted_image003.png" /&gt;&lt;/p&gt;
&lt;h2&gt;DATA STORAGE&lt;/h2&gt;
&lt;p&gt;physical pb: storage is cheap → use data redundancy 
logical pb: poor metadata, etc&lt;/p&gt;
&lt;p&gt;⇒ solutions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;publish &lt;em&gt;data specifications&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;data mining tools&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;DATA RETRIEVAL&lt;/h2&gt;
&lt;p&gt;...总之就是各种方面都会引起data quality pb... &lt;/p&gt;
&lt;h2&gt;DATA QUALITY CONSTRAINTS&lt;/h2&gt;
&lt;p&gt;static constraints: 
ex. nulls not allowed, field domains&lt;/p&gt;
&lt;p&gt;data constraints follow a 80-20 rule: &lt;br /&gt;
&lt;img alt="" src="sparkmooc_note_lec7/pasted_image004.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Data quality metrics&lt;/strong&gt;: ...
ex. in lab2, examine log lines that are not correctly parsed.&lt;/p&gt;
&lt;h2&gt;TECHNICAL APPROACHES TO DATA QUALITY&lt;/h2&gt;
&lt;p&gt;ex. entity resolution in lab3&lt;/p&gt;
&lt;h2&gt;EXAMPLE: DEDUP/CLEANING&lt;/h2&gt;
&lt;p&gt;bing shopping被黑了
convert to &lt;em&gt;canonical form &lt;/em&gt;(ex. mailing address)&lt;/p&gt;</summary><category term="spark"></category></entry><entry><title>[Spark MOOC note] Lec6. Structured Data</title><link href="http://x-wei.github.io/sparkmooc_note_lec6.html" rel="alternate"></link><updated>2015-06-18T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/sparkmooc_note_lec6.html</id><summary type="html">&lt;h2&gt;RELATIONAL DATABASE&lt;/h2&gt;
&lt;p&gt;review: key data management concepts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;data model &lt;/li&gt;
&lt;li&gt;schema&lt;/li&gt;
&lt;li&gt;&lt;em&gt;relational data model&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;structured data: have a specific schema to start with&lt;/p&gt;
&lt;p&gt;relationl database: a set of relations.
2 parts to a Relation: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;schema: name of relation, name and type of columns&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="sparkmooc_note_lec6//pasted_image.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;instance: &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;any data at given time 
(&lt;em&gt;cardinality&lt;/em&gt;:=nb of rows, &lt;em&gt;degree&lt;/em&gt;:=nb of fields)&lt;/p&gt;
&lt;h2&gt;LARGE DATABASES&lt;/h2&gt;
&lt;h2&gt;RELATIONAL DATABASE EXAMPLE AND DISCUSSION&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" src="sparkmooc_note_lec6//pasted_image001.png" /&gt; &lt;br /&gt;
cardinality=3
degree=5&lt;/p&gt;
&lt;p&gt;advantages of Relational Databases:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;well-def structure&lt;/li&gt;
&lt;li&gt;maintain indices for high performance&lt;/li&gt;
&lt;li&gt;consistancy maintained by transactions&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;disadvantages: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;limited, rigid structure&lt;/li&gt;
&lt;li&gt;most disk space taken by large indices&lt;/li&gt;
&lt;li&gt;transactions are slow&lt;/li&gt;
&lt;li&gt;poor support for &lt;em&gt;sparse data&lt;/em&gt;(which is common)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;STRUCTURED QUERY LANGUAGE (SQL)&lt;/h2&gt;
&lt;p&gt;supported by &lt;strong&gt;DataFrame&lt;/strong&gt; of pyspark &lt;br /&gt;
&lt;img alt="" src="sparkmooc_note_lec6//pasted_image002.png" /&gt;&lt;/p&gt;
&lt;h2&gt;JOINS IN SQL&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" src="sparkmooc_note_lec6//pasted_image003.png" /&gt;
cross join: carteian product&lt;/p&gt;
&lt;h2&gt;EXPLICIT SQL JOINS&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" src="sparkmooc_note_lec6//pasted_image004.png" /&gt;
explicit version is preferred&lt;/p&gt;
&lt;h2&gt;TYPES OF SQL JOINS&lt;/h2&gt;
&lt;p&gt;⇒ controls how &lt;em&gt;unmatched&lt;/em&gt; keys are handled&lt;/p&gt;
&lt;p&gt;LEFT OUTER JOIN: 
keys appearring in left table but not in right table will be included with NULL as value&lt;/p&gt;
&lt;h2&gt;JOINS IN SPARK&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;for spark DataFrame: support inner/left outer/semi-join&lt;/li&gt;
&lt;li&gt;for &lt;em&gt;pair RDDs&lt;/em&gt;: support inner join(), leftOuterJoin(), fullOuterJoin()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;join ex:
&lt;img alt="" src="sparkmooc_note_lec6//pasted_image005.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="sparkmooc_note_lec6//pasted_image006.png" /&gt;&lt;/p&gt;
&lt;p&gt;outerjoin ex:
&lt;img alt="" src="sparkmooc_note_lec6//pasted_image007.png" /&gt;&lt;/p&gt;
&lt;p&gt;fullouterjoin ex:
&lt;img alt="" src="sparkmooc_note_lec6//pasted_image008.png" /&gt;&lt;/p&gt;
&lt;h2&gt;Lab 2 - Web Server Log Analysis with Apache Spark&lt;/h2&gt;
&lt;p&gt;Apache Common Log Format (CLF):&lt;br /&gt;
&lt;code&gt;127.0.0.1 - - [01/Aug/1995:00:00:01 -0400] "GET /images/launch-logo.gif HTTP/1.0" 200 1839&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Row(
host          = match.group(1),
client_identd = match.group(2),
user_id       = match.group(3),
date_time     = parse_apache_time(match.group(4)),
method        = match.group(5),
endpoint      = match.group(6),
protocol      = match.group(7),
response_code = int(match.group(8)),
content_size  = size 
)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;distinctByKey&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个pair RDD按照key来distinct不知道有没有distinctByKey之类的东西, 只好写成这样, 不知是不是对的: 
&lt;code&gt;dayHostCount = dayGroupedHosts.map(lambda group : (group[0], len(set(group[1])) ) )&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;...总体来说很有意思的一个lab...&lt;/p&gt;</summary><category term="spark"></category></entry><entry><title>[Spark MOOC note] Lec5. Semi-structured Data</title><link href="http://x-wei.github.io/sparkmooc_note_lec5.html" rel="alternate"></link><updated>2015-06-17T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/sparkmooc_note_lec5.html</id><summary type="html">&lt;h2&gt;KEY DATA MANAGEMENT CONCEPTS&lt;/h2&gt;
&lt;p&gt;data model: collection of concepts for describing data
schema: a description of a particular collection of data using a given data model&lt;/p&gt;
&lt;p&gt;structure spectrum: &lt;br /&gt;
&lt;img alt="" src="sparkmooc_note_lec5/pasted_image.png" /&gt;
semi-structured data: apply schema &lt;strong&gt;after&lt;/strong&gt; creating data. &lt;/p&gt;
&lt;h2&gt;FILES&lt;/h2&gt;
&lt;p&gt;files: named collection of bytes, in hierarchical namespace (but: In a Content-Addressable Storage system files are stored, arranged, and accessed based on their content or metadata, not in hierarchy)&lt;/p&gt;
&lt;h2&gt;SEMI-STRUCTURED TABULAR DATA&lt;/h2&gt;
&lt;p&gt;table: a collection of rows and columns, each row has an &lt;em&gt;index&lt;/em&gt;, each column has a &lt;em&gt;name&lt;/em&gt;. 
cell: by a pair (row, col), values can be missing, types are &lt;em&gt;inffered&lt;/em&gt; from content&lt;/p&gt;
&lt;p&gt;CSV:&lt;br /&gt;
&lt;img alt="" src="sparkmooc_note_lec5/pasted_image002.png" /&gt;&lt;/p&gt;
&lt;p&gt;PDB:(filed name can be repeated on multuple lines)  &lt;br /&gt;
&lt;img alt="" src="sparkmooc_note_lec5/pasted_image001.png" /&gt; &lt;/p&gt;
&lt;h2&gt;CHALLENGES WITH TABULAR DATA&lt;/h2&gt;
&lt;p&gt;challenges: &lt;br /&gt;
&lt;img alt="" src="sparkmooc_note_lec5/pasted_image003.png" /&gt;&lt;/p&gt;
&lt;p&gt;challenges for tabular data &lt;em&gt;from multiple source&lt;/em&gt;: &lt;br /&gt;
&lt;img alt="" src="sparkmooc_note_lec5/pasted_image004.png" /&gt;&lt;/p&gt;
&lt;p&gt;challenges for tabular data &lt;em&gt;from sensors&lt;/em&gt;: &lt;br /&gt;
&lt;img alt="" src="sparkmooc_note_lec5/pasted_image005.png" /&gt;&lt;/p&gt;
&lt;h2&gt;PANDAS AND SEMI-STRUCTURED DATA IN PYSPARK&lt;/h2&gt;
&lt;p&gt;pandas &lt;code&gt;DataFrame&lt;/code&gt;: represented as python dict (colname → series)
pandas &lt;code&gt;Series&lt;/code&gt;: 1D labeled array capable of holding any data type&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;spark DataFrame&lt;/strong&gt;: &lt;em&gt;Distributed&lt;/em&gt; collection of data organized into named columns. 
types of columns are inferred from values. &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="sparkmooc_note_lec5/pasted_image006.png" /&gt;&lt;/p&gt;
&lt;p&gt;Using dataframes can be 5 times faster than using RDDs: &lt;br /&gt;
&lt;img alt="" src="sparkmooc_note_lec5/pasted_image007.png" /&gt;&lt;/p&gt;
&lt;h2&gt;SEMI-STRUCTURED LOG FILES&lt;/h2&gt;
&lt;p&gt;ex. Apache web server log format&lt;/p&gt;
&lt;h2&gt;EXPLORING A WEB SERVER ACCESS LOG&lt;/h2&gt;
&lt;p&gt;NASA http server access log&lt;br /&gt;
&lt;a href="http://ita.ee.lbl.gov/html/contrib/NASA-HTTP.html"&gt;http://ita.ee.lbl.gov/html/contrib/NASA-HTTP.html&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;DATA MINING LOG FILES&lt;/h2&gt;
&lt;p&gt;Data mining log files is a data exploration process that often involves searching through the data for unusual events, a task that can be done using dashboards for visualizing anomalies. The data being analyzed usually includes machine resource usage data and application queue information.&lt;/p&gt;
&lt;h2&gt;FILE PERFORMANCE&lt;/h2&gt;
&lt;p&gt;binary/text performance benchmark:&lt;br /&gt;
&lt;img alt="" src="sparkmooc_note_lec5/pasted_image008.png" /&gt;&lt;br /&gt;
⇒&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;read and write times are comparable &lt;/li&gt;
&lt;li&gt;binary files are mach faster than palin text files&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;compression performance benchmark:&lt;br /&gt;
&lt;img alt="" src="sparkmooc_note_lec5/pasted_image009.png" /&gt;&lt;br /&gt;
⇒ &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;write times are much larger than read times &lt;/li&gt;
&lt;li&gt;small range of compressed file size&lt;/li&gt;
&lt;li&gt;binary still much faster than text &lt;/li&gt;
&lt;li&gt;LZ4 compression ~= raw IO speed&lt;/li&gt;
&lt;/ul&gt;</summary><category term="spark"></category></entry><entry><title>[Spark MOOC note] Lec4. Spark Essentials</title><link href="http://x-wei.github.io/sparkmooc_note_lec4.html" rel="alternate"></link><updated>2015-06-16T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/sparkmooc_note_lec4.html</id><summary type="html">&lt;h2&gt;PYTHON SPARK (PYSPARK)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;a spark prog has 2 programs:&lt;/strong&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dirver program: runs on driver machine&lt;/li&gt;
&lt;li&gt;worker program: runs on local threads or cluster nodes&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;a spark prog first creates a &lt;strong&gt;SparkContext object:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tells how and where to access a cluster&lt;/li&gt;
&lt;li&gt;shell will automatically create &lt;strong&gt;the sc varible&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;in iPython: use constructor to create a &lt;code&gt;SparkContext&lt;/code&gt; obj&lt;/li&gt;
&lt;li&gt;⇒ use this SparkContext obj to create RDDs&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Master:&lt;br /&gt;
The &lt;code&gt;master&lt;/code&gt; parameter (for a SparkContext) determines which type and size of cluster to use
&lt;img alt="" src="./sparkmooc_note_lec4/pasted_image.png" /&gt;&lt;/p&gt;
&lt;h2&gt;RDDs&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Resilient Distributed Dataset&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;immutable once created&lt;/li&gt;
&lt;li&gt;spark tracks linege information to compute lost data efficiently&lt;/li&gt;
&lt;li&gt;operations on collections of elements in parallel&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;to create RDDs&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;paralizing existing python collections&lt;/li&gt;
&lt;li&gt;transforming existing RDDs&lt;/li&gt;
&lt;li&gt;from files&lt;/li&gt;
&lt;li&gt;can specify the number of partitions for an RDD&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="./sparkmooc_note_lec4/pasted_image002.png" /&gt;&lt;/p&gt;
&lt;p&gt;2 types of operations on RDD:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tranformation: lazy, &lt;em&gt;executed only one action runs on it&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;action&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Working with RDD:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;create an RDD&lt;/li&gt;
&lt;li&gt;apply transformations to that RDD (ex. map, filter)&lt;/li&gt;
&lt;li&gt;apply actions on RDD (collect, count)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ex code:  &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;rDD&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;paralize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;distFile&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;textFile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;readme.txt&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// elements are lines in the file&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;SPARK TRANSFORMATIONS&lt;/h2&gt;
&lt;p&gt;to create new dataset from existing one (lazy)&lt;/p&gt;
&lt;p&gt;examples of transformations: &lt;br /&gt;
&lt;img alt="" src="./sparkmooc_note_lec4/pasted_image003.png" /&gt;&lt;/p&gt;
&lt;h2&gt;PYTHON LAMBDA FUNCTIONS&lt;/h2&gt;
&lt;p&gt;single expression&lt;/p&gt;
&lt;h2&gt;TRANSFORMATIONS&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" src="./sparkmooc_note_lec4/pasted_image004.png" /&gt;&lt;/p&gt;
&lt;p&gt;⇒ spark truns the function litral into a cloture, balck code runs in driver, green code in workers&lt;/p&gt;
&lt;h2&gt;SPARK ACTIONS&lt;/h2&gt;
&lt;p&gt;cause spark to execute recipe to transform source. 
&lt;img alt="" src="./sparkmooc_note_lec4/pasted_image006.png" /&gt;&lt;/p&gt;
&lt;h2&gt;SPARK PROGRAMMING MODEL&lt;/h2&gt;
&lt;h2&gt;CACHING RDDS&lt;/h2&gt;
&lt;p&gt;to avoid having to reload data: &lt;code&gt;rdd.cache()&lt;/code&gt;⇒ read from memory instead of disk&lt;br /&gt;
&lt;img alt="" src="./sparkmooc_note_lec4/pasted_image007.png" /&gt;&lt;/p&gt;
&lt;h2&gt;SPARK PROGRAM LIFECYCLE&lt;/h2&gt;
&lt;p&gt;create/paralise ⇒ transform ⇒ [cache] ⇒ action&lt;/p&gt;
&lt;h2&gt;SPARK KEY-VALUE RDDS&lt;/h2&gt;
&lt;p&gt;each element of a &lt;em&gt;pair RDD&lt;/em&gt; is a pair tuple&lt;/p&gt;
&lt;p&gt;key-value transformations: &lt;br /&gt;
&lt;img alt="" src="./sparkmooc_note_lec4/pasted_image008.png" /&gt;&lt;/p&gt;
&lt;p&gt;ex:&lt;br /&gt;
&lt;img alt="" src="./sparkmooc_note_lec4/pasted_image009.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./sparkmooc_note_lec4/pasted_image010.png" /&gt;&lt;/p&gt;
&lt;p&gt;careful using &lt;code&gt;groupByKey&lt;/code&gt;: create lots of data traffic and iterables at works&lt;/p&gt;
&lt;h2&gt;PYSPARK CLOSURES&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;one closure per worker is sent &lt;em&gt;with every task&lt;/em&gt; &lt;/li&gt;
&lt;li&gt;no communication between workers&lt;/li&gt;
&lt;li&gt;changes to global vars will not effect driver / other workers&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;⇒ pbs: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;inefficient to send large data to each job&lt;/li&gt;
&lt;li&gt;one-way: driver → worker&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;pyspark shared vaiables&lt;/strong&gt;: 
2 types: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Broadcase variables&lt;/strong&gt;:&lt;ul&gt;
&lt;li&gt;send large, read-only variables to all workers&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Accumulators&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;aggregate values from worker to drivers &lt;/li&gt;
&lt;li&gt;only driver can access its value&lt;/li&gt;
&lt;li&gt;for workers the accumulators are write-only&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;SPARK BROADCAST VARIABLES&lt;/h2&gt;
&lt;p&gt;ex. give every worker a large dataset &lt;br /&gt;
&lt;img alt="" src="./sparkmooc_note_lec4/pasted_image011.png" /&gt;&lt;/p&gt;
&lt;h2&gt;SPARK ACCUMULATORS&lt;/h2&gt;
&lt;p&gt;can only be "add" to by associative operation &lt;br /&gt;
&lt;img alt="" src="./sparkmooc_note_lec4/pasted_image012.png" /&gt;&lt;/p&gt;
&lt;p&gt;careful to use accumulators in transformations: &lt;br /&gt;
&lt;img alt="" src="./sparkmooc_note_lec4/pasted_image013.png" /&gt;&lt;/p&gt;
&lt;h2&gt;Lab1&lt;/h2&gt;
&lt;p&gt;VB更新以后虚拟机打不开了, 解决办法在: &lt;br /&gt;
&lt;a href="http://bbs.deepin.org/forum.php?mod=viewthread&amp;amp;tid=26001"&gt;http://bbs.deepin.org/forum.php?mod=viewthread&amp;amp;tid=26001&lt;/a&gt;&lt;/p&gt;</summary><category term="spark"></category></entry></feed>